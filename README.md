## NOTE, following is a very high level description of **IoC.Configuration**. For more details please refer to a more complete documentation at [http://iocconfiguration.readthedocs.io](http://iocconfiguration.readthedocs.io), and also look at configuration files in [https://github.com/artakhak/IoC.Configuration/tree/master/IoC.Configuration.Tests](https://github.com/artakhak/IoC.Configuration/tree/master/IoC.Configuration.Tests) and the tests that use these files.
***

The main functions of IoC.Configuration library are:
1)  Container agnostic configuration of dependency injection using XML configuration file. The file has section where container can be specified, that will be handling dependency injection resolutions.
Currently two popular containers are supported, **Ninject** and **Autofac**, via extension libraries **IoC.Configuration.Ninject** and **IoC.Configuration.Autofac**, that are available in Nuget.org.
The dependency injection container (e.g., **Autofac**, **Ninject**) can be easily switched in configuration file.
In addition, the configuration file has sections for settings, plugins, startup actions, dynamically generated implementations of interfaces (see elements **iocConfiguration/dependencyInjection/autoGeneratedServices/autoService** and **iocConfiguration/dependencyInjection/autoGeneratedServices/autoServiceCustom** in example configuration files in GitHub test project [IoC.Configuration.Tests](https://github.com/artakhak/IoC.Configuration/tree/master/IoC.Configuration.Tests)).
  
2) Container agnostic configuration of dependency injection in code. 
***
The bindings are specified using **IoC.Configuration** chained methods, however the actual resolutions are done using one of the popular dependency injection containers, **Ninject** and **Autofac**, via extension libraries **IoC.Configuration.Ninject** and **IoC.Configuration.Autofac**.
***

## Configuration
Dependency injection can be configured either using file based or code based configuration builder.

Bindings can be specified in three different ways:

-In configuration file (for file based configuration only).

-Using native modules (for example using Autofac and Ninject modules).
 
-By extending the class  IoC.Configuration.DiContainer.ModuleAbstr and overriding the method AddServiceRegistrations() or by implementing IoC.Configuration.IDiModule.

In file based configuration, the modules (Autofac, Ninject, or implementations of IoC.Configuration.IDiModule) can be specified in configuration file in element iocConfiguration/dependencyInjection/modules/module

In code based configuration, the modules can be passed as parameters in chained configuration methods (see the section Code Based Configuration).
 
**Below is an example of specifying bindings in AddServiceRegistrations() method in a subclass of IoC.Configuration.DiContainer.ModuleAbstr (note the example is taken from test project so the class names are not user friendly).**

```csharp
// This file is used in documentation as demo
using IoC.Configuration.DiContainer;
using System.Collections.Generic;
using IoC.Configuration.Tests.SuccessfulDiModuleLoadTests.TestClasses;

namespace IoC.Configuration.Tests.SuccessfulDiModuleLoadTests;

public class TestDiModule : IoC.Configuration.DiContainer.ModuleAbstr
{
    protected override void AddServiceRegistrations()
    {
        Bind<Class1>().ToSelf()
            .SetResolutionScope(DiResolutionScope.Singleton);
        Bind<IInterface1>().To<Interface1_Impl1>()
            .SetResolutionScope(DiResolutionScope.Singleton);
        Bind<Class2>().ToSelf()
            .SetResolutionScope(DiResolutionScope.Transient);
        Bind<IInterface2>().To<Interface2_Impl1>()
            .SetResolutionScope(DiResolutionScope.Transient);
        Bind<Class3>().ToSelf()
            .SetResolutionScope(DiResolutionScope.ScopeLifetime);
        Bind<IInterface3>().To<Interface3_Impl1>()
            .SetResolutionScope(DiResolutionScope.ScopeLifetime);
        Bind<Class4>().ToSelf()
            .SetResolutionScope(DiResolutionScope.Singleton);
        Bind<Class4>().ToSelf()
            .SetResolutionScope(DiResolutionScope.Transient);

        // The first binding should be with Singleton scope, and the second
        // should with Transient, so that we can test that the first binding was used.
        Bind<Class5>().OnlyIfNotRegistered()
            .ToSelf().SetResolutionScope(DiResolutionScope.Singleton);
        Bind<Class5>().OnlyIfNotRegistered()
            .ToSelf().SetResolutionScope(DiResolutionScope.Transient);

        // Only the first binding below will be registered.
        Bind<IInterface4>().OnlyIfNotRegistered().To<Interface4_Impl1>()
            .SetResolutionScope(DiResolutionScope.Transient);
        Bind<IInterface4>().OnlyIfNotRegistered().To<Interface4_Impl2>()
            .SetResolutionScope(DiResolutionScope.Singleton);

        // Both binding below will be registered
        Bind<IInterface5>().OnlyIfNotRegistered()
            .To<Interface5_Impl1>()
            .SetResolutionScope(DiResolutionScope.Transient);
        Bind<IInterface5>().To<Interface5_Impl2>()
            .SetResolutionScope(DiResolutionScope.Singleton);

        // Test delegates and resolution using IDiContainer
        Bind<IInterface6>()
            .To(diContainer => new Interface6_Impl1(11, diContainer.Resolve<IInterface1>()));

        // Test delegates that return a collection using IDiContainer
        Bind<IEnumerable<IInterface7>>().To(x => new List<IInterface7>()
        {
            new Interface7_Impl1(10),
            new Interface7_Impl1(11)
        }).SetResolutionScope(DiResolutionScope.Singleton);

        Bind<IInterface8>().To<Interface8_Impl1>().SetResolutionScope(DiResolutionScope.Singleton);

        #region Test circular references

        Bind<ICircularReferenceTestInterface1>()
            .To<CircularReferenceTestInterface1_Impl>()
            .OnImplementationObjectActivated(
                (diContainer, instance) =>
                    // Note, type of parameter 'instance' is the implementation type
                    // CircularReferenceTestInterface1_Impl. So we can use Property1 setter in
                    // CircularReferenceTestInterface1_Impl only and not in ICircularReferenceTestInterface1.
                    // ICircularReferenceTestInterface1 has only getter for Property1.
                    instance.Property1 = diContainer.Resolve<ICircularReferenceTestInterface2>())
            .SetResolutionScope(DiResolutionScope.Singleton);

        Bind<ICircularReferenceTestInterface2>().To<CircularReferenceTestInterface2_Impl>()
            .SetResolutionScope(DiResolutionScope.Singleton);
        #endregion
    }
}
```
      
## File Based Configuration
Example of configuration file is shown below.

Here is an example of configuring and starting the container:

```csharp
        
TestsSharedLibrary.TestsHelper.SetupLogger();

var configurationFileContentsProvider = new FileBasedConfigurationFileContentsProvider(
                Path.Combine(Helpers.TestsEntryAssemblyFolder, "IoCConfiguration_Overview.xml"));

using (var containerInfo = new DiContainerBuilder.DiContainerBuilder()
           .StartFileBasedDi(
               new FileBasedConfigurationParameters(configurationFileContentsProvider,
                   Helpers.TestsEntryAssemblyFolder,
                   new LoadedAssembliesForTests())
               {
                   AdditionalReferencedAssemblies = new []
                   {
                       // List additional assemblies that should be added to dynamically generated assembly as references
                       Path.Combine(Helpers.GetTestFilesFolderPath(), @"DynamicallyLoadedDlls\TestProjects.DynamicallyLoadedAssembly1.dll"),
                       Path.Combine(Helpers.GetTestFilesFolderPath(), @"DynamicallyLoadedDlls\TestProjects.DynamicallyLoadedAssembly2.dll")
                   },
                   AttributeValueTransformers = new[] {new FileFolderPathAttributeValueTransformer()},
                   ConfigurationFileXmlDocumentLoaded = (sender, e) =>
                   {
                       // Replace some elements in e.XmlDocument if needed,
                       // before the configuration is loaded.
                       Helpers.EnsureConfigurationDirectoryExistsOrThrow(e.XmlDocument.SelectElement("/iocConfiguration/appDataDir").GetAttribute("path"));
                   }
               }, out _)
           .WithoutPresetDiContainer()
           .AddAdditionalDiModules(new TestDiModule())
           .RegisterModules()
           .Start())
{
    var container = containerInfo.DiContainer;

    Assert.IsNotNull(containerInfo.DiContainer.Resolve<IInterface6>());

    var settings = container.Resolve<ISettings>();
    Assert.AreEqual(155.7, settings.GetSettingValueOrThrow<double>("MaxCharge"));

    var pluginRepository = container.Resolve<IPluginDataRepository>();

    var pluginData = pluginRepository.GetPluginData("Plugin1");
    Assert.AreEqual(38, pluginData.Settings.GetSettingValueOrThrow<long>("Int64Setting1"));
}

```

**The configuration file IoCConfiguration_Overview.xml available in [https://github.com/artakhak/IoC.Configuration/tree/master/IoC.Configuration.Tests](https://github.com/artakhak/IoC.Configuration/tree/master/IoC.Configuration.Tests)**

```XML

<?xml version="1.0" encoding="utf-8"?>

<!--This is a demo IoC.Configuration file. Even though this configuration file, along with tests in folder SuccessfulConfigurationLoadTests
  covers many use cases, some concepts are covered in more details in separate configuration files and tests.
  Here is the list of other configuration files and tests that cover specific use cases:
  
  Type reuse, generic types and arrays (elements typeDefinitions and typeDefinition and referencing types defined under typeDefinitions 
        element using attributes like typeRef, interfaceRef, classRef, etc): Look at configuration file 
        IoCConfiguration_GenericTypesAndTypeReUse.xml and tests in folder GenericTypesAndTypeReUse.  
  Element autoService: look at configuration file IoCConfiguration_autoService.xml and tests in folder AutoService.
  Element autoServiceCustom: look at configuration file IoCConfiguration_autoServiceCustom.xml and tests in folder AutoService.
  Element collection: look at configuration file IoCConfiguration_collection.xml and tests in folder Collection.
  Element classMember and _classMember: prefix in "if" elements under autoMethod elements: look at configuration file 
            IoCConfiguration_classMember.xml and tests in folder ClassMember.
  Element settingValue: look at configuration file IoCConfiguration_settingValue_ReferencingInConfiguration.xml and tests in folder SettingValue.
  Element constructedValue: look at configuration file IoCConfiguration_constructedValue.xml and tests in folder ConstructedValue.  
  Element proxyService: look at configuration file IoCConfiguration_proxyService.xml and tests in folder ProxyService.
 
  Element valueImplementation (to provide implementation as a value). Example is using a classMember, or settingValue elements to 
     provide an implementation for a service.: look at configuration file IoCConfiguration_valueImplementation.xml and tests in folder ValueImplementation.
-->
<!--
   The XML configuration file is validated against schema file IoC.Configuration.Schema.7579ADB2-0FBD-4210-A8CA-EE4B4646DB3F.xsd, 
   which can be found in folder IoC.Configuration.Content in output directory. 
   The schema file can also be downloaded from 
   http://oroptimizer.com/ioc.configuration/V2/IoC.Configuration.Schema.7579ADB2-0FBD-4210-A8CA-EE4B4646DB3F.xsd or in source code 
   project in Github.com.
   
   To use Visual Studio code completion based on schema contents, right click Properties on this file in Visual Studio, and in Schemas 
   field pick the schema IoC.Configuration.Schema.7579ADB2-0FBD-4210-A8CA-EE4B4646DB3F.xsd.

   Before running the tests make sure to execute IoC.Configuration\Tests\IoC.Configuration.Tests\PostBuildCommands.bat to copy the dlls into 
   folders specified in this configuration file.
   Also, modify the batch file to copy the Autofac and Ninject assemblies from Nuget packages folder on machine, where the test is run.
-->

<iocConfiguration
	xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance'
	xsi:noNamespaceSchemaLocation="http://oroptimizer.com/IoC.Configuration/V2/IoC.Configuration.Schema.7579ADB2-0FBD-4210-A8CA-EE4B4646DB3F.xsd">

	<!--The application should have write permissions to path specified in appDataDir. 
    This is where dynamically generated DLLs are saved.-->
	<!--NOTE: path should be an absolute path, or should be converted to absolute path by some implementation of 
	IoC.Configuration.AttributeValueTransformer.IAttributeValueTransformer. In this example the paths are converted by 
	IoC.Configuration.Tests.FileFolderPathAttributeValueTransformer.-->
	<appDataDir
		path="TestFiles\AutogeneratedDlls\IoCConfiguration_Overview" />

	<plugins pluginsDirPath="TestFiles\PluginDlls">

		<!--        
        Plugin assemblies will be in a folder with similar name under pluginsDirPath folder.
        The plugin folders will be included in assembly resolution mechanism.        
        -->

		<!--A folder K:\...\IoC.Configuration\Tests\IoC.Configuration.Tests\bin\TestFiles\PluginDlls\Plugin1 should exist.  -->
		<plugin name="Plugin1" />
		<plugin name="Plugin2" />
		<plugin name="Plugin3" enabled="false" />
	</plugins>

	<additionalAssemblyProbingPaths>
		<probingPath
			path="TestFiles\ThirdPartyLibs" />
		<probingPath
			path="TestFiles\ContainerImplementations\Autofac" />
		<probingPath
			path="TestFiles\ContainerImplementations\Ninject" />

		<probingPath
			path="TestFiles\DynamicallyLoadedDlls" />
		<probingPath
			path="TestFiles\TestAssemblyResolution" />
	</additionalAssemblyProbingPaths>

	<assemblies>
		<!--Assemblies should be in one of the following locations:
        1) Executable's folder
        2) In folder specified in additionalAssemblyProbingPaths element.
        3) In one of the plugin folders specified in plugins element (only for assemblies with plugin attribute) -->
		<assembly name="OROptimizer.Shared" alias="oroptimizer_shared" />
		<assembly name="IoC.Configuration" alias="ioc_config" />
		<assembly name="IoC.Configuration.Autofac" alias="autofac_ext" />
		<assembly name="IoC.Configuration.Ninject" alias="ninject_ext" />

		<assembly name="TestProjects.Modules" alias="modules" />

		<!--        
        Use "overrideDirectory" attribute, to make the assembly path explicit, rather then searching for
        an assembly in predefined folders, which also include
        probing paths specified in additionalAssemblyProbingPaths element.
        -->
		<assembly name="TestProjects.DynamicallyLoadedAssembly1"
				  alias="dynamic1" overrideDirectory="TestFiles\DynamicallyLoadedDlls"/>

		<assembly name="TestProjects.DynamicallyLoadedAssembly2"
		          alias="dynamic2" />

		<assembly name="TestProjects.TestPluginAssembly1"
				  alias="pluginassm1" plugin="Plugin1" />

		<assembly name="TestProjects.ModulesForPlugin1"
				  alias="modules_plugin1" plugin="Plugin1" />

		<assembly name="TestProjects.Plugin1WebApiControllers"
				  alias="plugin1api" plugin="Plugin1" />


		<assembly name="TestProjects.TestPluginAssembly2"
				  alias="pluginassm2" plugin="Plugin2" />

		<assembly name="TestProjects.ModulesForPlugin2"
				  alias="modules_plugin2" plugin="Plugin2"/>

		<assembly name="TestProjects.TestPluginAssembly3"
				  alias="pluginassm3" plugin="Plugin3" />

		<assembly name="TestProjects.SharedServices" alias="shared_services" />

		<assembly name="IoC.Configuration.Tests" alias="tests" />
	</assemblies>

	<typeDefinitions>
		<!--For more examples of type definitions and generic types, arrays, and re-using types defined under
		typeDefinition element look at file IoCConfiguration_GenericTypesAndTypeReUse.xml, as well as tests 
		in folder GenericTypesAndTypeReUse.
		-->
		<typeDefinition alias="ReadOnlyListOf_IInterface1" type="System.Collections.Generic.IReadOnlyList[SharedServices.Interfaces.IInterface1]" />

		<!--The type definition below is similar to C# type System.Collections.Generic.IEnumerable<SharedServices.Interfaces.IInterface1[]>-->
		<typeDefinition alias="enumerableOfArray" type="System.Collections.Generic.IEnumerable[SharedServices.Interfaces.IInterface1#]" />

		<!--The type definition below is similar to C# type System.Collections.Generic.IList<SharedServices.Interfaces.IInterface1[]>-->
		<typeDefinition alias="listOfArray" type="System.Collections.Generic.IList" >
			<genericTypeParameters>
				<typeDefinition type="SharedServices.Interfaces.IInterface1#" />
			</genericTypeParameters>
		</typeDefinition>

		<typeDefinition alias="AutoService_IInterface1" type="IoC.Configuration.Tests.AutoService.Services.IInterface1" />
		<typeDefinition alias="IActionValidator" type="SharedServices.Interfaces.IActionValidator" />
		<typeDefinition alias="IProjectGuids" type="IoC.Configuration.Tests.AutoService.Services.IProjectGuids" />
		<typeDefinition alias="ActionTypes" type="SharedServices.DataContracts.ActionTypes" />
		<typeDefinition alias="Guid" type="System.Guid" />
		<typeDefinition alias="ListOfInt" type="System.Collections.Generic.List[System.Int32]" >
		</typeDefinition>
	</typeDefinitions>

	<!--assembly attribute is not required, and only is needed to make sure the type is looked at specific assembly
    If the assembly attribute is omitted, the type will be looked in all assemblies specified in assemblies, plus some additional 
    assemblies such as OROptimizer.Shared, IoC.Configuration, etc.
	-->
	<parameterSerializers serializerAggregatorType="OROptimizer.Serializer.TypeBasedSimpleSerializerAggregator"
						  assembly="oroptimizer_shared">
		<!--
        Use parameters element to specify constructor parameters, if the type specified in 'serializerAggregatorType' attribute
        has non-default constructor.
        -->
		<!--<parameters>
        </parameters>-->
		<serializers>
			<parameterSerializer type="OROptimizer.Serializer.TypeBasedSimpleSerializerDouble" />
			<parameterSerializer type="OROptimizer.Serializer.TypeBasedSimpleSerializerLong" />
			<parameterSerializer type="OROptimizer.Serializer.TypeBasedSimpleSerializerInt"/>
			<parameterSerializer type="OROptimizer.Serializer.TypeBasedSimpleSerializerShort"/>
			<parameterSerializer type="OROptimizer.Serializer.TypeBasedSimpleSerializerByte" />
			<parameterSerializer type="OROptimizer.Serializer.TypeBasedSimpleSerializerBoolean" />
			<parameterSerializer type="OROptimizer.Serializer.TypeBasedSimpleSerializerDateTime" />
			<parameterSerializer type="OROptimizer.Serializer.TypeBasedSimpleSerializerString" />
			<parameterSerializer type="TestPluginAssembly1.Implementations.DoorSerializer" />
			<parameterSerializer type="TestPluginAssembly2.Implementations.WheelSerializer" />

			<parameterSerializer type="TestPluginAssembly1.Implementations.UnsignedIntSerializerWithParameters" >
				<parameters>
					<int32 name="param1" value="25" />
					<double name="param2" value="36.5" />
				</parameters>
			</parameterSerializer>
		</serializers>

	</parameterSerializers>

	<!--The value of type attribute should be a type that implements 
    IoC.Configuration.DiContainer.IDiManager-->
	<diManagers activeDiManagerName="Autofac">
		<diManager name="Ninject" type="IoC.Configuration.Ninject.NinjectDiManager">
			<!--
            Use parameters element to specify constructor parameters,
            if the type specified in 'type' attribute has non-default constructor.
            -->
			<!--<parameters>
            </parameters>-->
		</diManager>

		<diManager name="Autofac" type="IoC.Configuration.Autofac.AutofacDiManager">
		</diManager>
	</diManagers>

	<!--
    If settingsRequestor element is used, the type in type attribute should 
    specify a type that implements IoC.Configuration.ISettingsRequestor. 
    The implementation specifies a collection of required settings that should be present
    in settings element.
    Note, the type specified in type attribute is fully integrated into a dependency 
    injection framework. In other words, constructor parameters will be injected using 
    bindings specified in dependencyInjection element.
    -->
	<settingsRequestor type="SharedServices.FakeSettingsRequestor">
	</settingsRequestor>

	<settings>
		<int32 name="SynchronizerFrequencyInMilliseconds" value="5000"  />
		<double name="MaxCharge" value="155.7" />
		<string name="DisplayValue" value="Some display value" />

		<!--NOTE: For more comprehensive examples for constructedValue element,
        look at file IoCConfiguration_constructedValue.xml and tests in folder ConstructedValue.-->
		<constructedValue name="DefaultDBConnection" type="SharedServices.Implementations.SqliteDbConnection">
			<parameters>
				<string name="filePath" value="c:\SQLiteFiles\MySqliteDb.sqlite"/>
			</parameters>
		</constructedValue>

		<object name="Project1Guid" typeRef="Guid" value="EA91B230-3FF8-43FA-978B-3261493D58A3" />
		<object name="Project2Guid" typeRef="Guid" value="9EDC7F1A-6BD6-4277-9015-5A9277218681" />

		<constructedValue name="Interface11_Value" type="SharedServices.Implementations.Interface11_Impl1">
			<parameters>
				<!-- Constructor parameter of  SharedServices.Implementations.Interface11 is injected using a constructedValue element-->
				<constructedValue name="param1" type="SharedServices.Implementations.Interface10_Impl1" >
					<parameters>
						<int32 name="param1" value="13" />
					</parameters>
					<injectedProperties>
						<string name="Property2" value="Value 1"/>
					</injectedProperties>
				</constructedValue>
			</parameters>

			<injectedProperties>
				<!-- Property SharedServices.Implementations.Interface11.Property2 is injected using a constructedValue element-->
				<constructedValue name="Property2" type="SharedServices.Implementations.Interface10_Impl1" >
					<parameters>
						<int32 name="param1" value="17"/>
					</parameters>
					<injectedProperties>
						<string name="Property2" value="Value 2"/>
					</injectedProperties>
				</constructedValue>

			</injectedProperties>
		</constructedValue>

		<!--NOTE: For more comprehensive examples for collection element,
        look at file IoCConfiguration_collection.xml and tests in folder Collection.-->
		<constructedValue name="Collections" type="IoC.Configuration.Tests.Collection.Services.DemoCollectionInjection">
			<parameters>
				<!--Demo of injecting a collection into a constructor of DemoCollectionInjection in constructedValue element.-->
				<collection name="intValues" collectionType="readOnlyList" itemType="System.Int32">
					<int32 value="17"/>
					<int32 value="14"/>
				</collection>
			</parameters>
			<injectedProperties>
				<!--Demo of injecting a collection into a property of DemoCollectionInjection in constructedValue element.-->
				<collection name="Texts" collectionType="readOnlyList" itemType="System.String">
					<string value="ABC, Inc"/>
					<string value="Microsoft"/>
				</collection>
			</injectedProperties>
		</constructedValue>

		<boolean name="failCustomServiceValidation" value="false"/>
	</settings>

	<!--
      webApi is an optional element that contains ASP.NET Core related 
      sections such as assemblies with API controllers, etc
    -->
	<webApi>
		<controllerAssemblies>
			<!--
			Specify assemblies with API controllers.
			The user of IoC.Configuration should add the assemblies to MVC using 
			IMvcBuilder.AddApplicationPart(System.Reflection.Assembly)
			-->
			<controllerAssembly assembly="dynamic1"></controllerAssembly>
		</controllerAssemblies>
	</webApi>

	<dependencyInjection>
		<modules>
			<module type="IoC.Configuration.Tests.PrimitiveTypeDefaultBindingsModule" >
				<parameters>
					<!--Date time can be also long value for ticks. For example the datetime value below can 
					be replaced with 604096704000000000-->
					<datetime name="defaultDateTime" value="1915-04-24 00:00:00.000" />
					<double name="defaultDouble" value="0" />
					<int16 name="defaultInt16" value="0" />
					<classMember name="defaultInt32" class="System.Int32" memberName="MinValue"/>
				</parameters>				
			</module>

			<!--Type Modules.Autofac.AutofacModule1 is an Autofac module and is a
                                            subclass of Autofac.AutofacModule-->
			<module type="Modules.Autofac.AutofacModule1" >
				<parameters>
					<int32 name="param1" value="1" />
				</parameters>
			</module>

			<!--Type Modules.IoC.DiModule1 is an IoC.Configuration module and is a subclass 
                of IoC.Configuration.DiContainer.ModuleAbstr-->
			<module type="Modules.IoC.DiModule1" >
				<parameters>
					<int32 name="param1" value="2" />
				</parameters>
			</module>

			<!--Type Modules.Ninject.NinjectModule1 is a Ninject module and is a
            subclass of Ninject.Modules.NinjectModule-->
			<module type="Modules.Ninject.NinjectModule1" >
				<parameters>
					<int32 name="param1" value="3" />
				</parameters>
			</module>

			<module type="IoC.Configuration.Tests.AutoService.AutoServiceTestsModule" />
		</modules>
		<services>
			<service type="DynamicallyLoadedAssembly1.Interfaces.IInterface1">
				<implementation type="DynamicallyLoadedAssembly1.Implementations.Interface1_Impl1"
								scope="singleton">
				</implementation>
			</service>

			<service type="DynamicallyLoadedAssembly1.Interfaces.IInterface2">
				<implementation type="DynamicallyLoadedAssembly1.Implementations.Interface2_Impl1"
								scope="transient">
				</implementation>
			</service>

			<service type="DynamicallyLoadedAssembly1.Interfaces.IInterface3">
				<implementation type="DynamicallyLoadedAssembly1.Implementations.Interface3_Impl1"
								scope="scopeLifetime">
				</implementation>
			</service>

			<!--
            Test DI picking the default constructor when instantiating the implementation, if parameters element is 
            present, and using non-default constructor otherwise, with injected parameters.
            -->
			<service type="SharedServices.Interfaces.IInterface9">
				<implementation type="SharedServices.Implementations.Interface9_Impl1"
								scope="singleton" />
			</service>
			<service type="SharedServices.Interfaces.IInterface8">
				<implementation type="SharedServices.Implementations.Interface8_Impl1"
								scope="singleton">
					<!--
                    Since parameters is present, a default constructor will be used to construct an object, even though 
                    Interface8_Impl1 has also a non default constructor.
                    -->
					<parameters>
					</parameters>
				</implementation>

				<implementation type="SharedServices.Implementations.Interface8_Impl2" scope="singleton">
					<!--
                    Since parameters is not present, DI will pick a constructor with maximum number of parameters.
                    Note, Interface8_Impl2 has two constructors, a default one, and a constructor with parameters.
                    -->
				</implementation>
			</service>

			<!--Injected constructor parameters with self bound services-->
			<selfBoundService type="DynamicallyLoadedAssembly1.Implementations.SelfBoundService1"
							  scope="singleton">
				<parameters>
					<int32 name="param1" value="14" />
					<double name="param2" value="15.3" />
					<injectedObject name="param3" type="DynamicallyLoadedAssembly1.Interfaces.IInterface1" />
				</parameters>
			</selfBoundService>

			<!--Injected properties with self bound services-->
			<selfBoundService type="DynamicallyLoadedAssembly1.Implementations.SelfBoundService2"
							  scope="transient">
				<injectedProperties>
					<int32 name="Property1" value="17" />
					<double name="Property2" value="18.1" />
					<injectedObject name="Property3" type="DynamicallyLoadedAssembly1.Interfaces.IInterface1" />
				</injectedProperties>
			</selfBoundService>

			<!--Life time scope with self bound services-->
			<selfBoundService type="DynamicallyLoadedAssembly1.Implementations.SelfBoundService3"
							  scope="scopeLifetime">
			</selfBoundService>

			<!--Test circular references between SharedServices.Interfaces.IInterface3 and SharedServices.Interfaces.IInterface4-->
			<service type="SharedServices.Interfaces.IInterface3" >
				<implementation type="SharedServices.Implementations.Interface3_Impl1"
								scope="singleton">
					<injectedProperties>
						<injectedObject name="Property2" type="SharedServices.Interfaces.IInterface4" />
					</injectedProperties>
				</implementation>
			</service>
			<service type="SharedServices.Interfaces.IInterface4">
				<implementation type="SharedServices.Implementations.Interface4_Impl1"
								scope="singleton">
				</implementation>
			</service>

			<!--Injected constructor parameters-->
			<service type="SharedServices.Interfaces.IInterface2" >
				<!--Test constructor parameters-->
				<implementation type="SharedServices.Implementations.Interface2_Impl1"
								scope="singleton">
					<parameters>
						<!--The value will be de-serialized using serializer TypeBasedSimpleSerializerDateTime 
                        in parameterSerializers section.-->
						<datetime name="param1" value="2014-10-29 23:59:59.099" />
						<double name="param2" value="125.1" />
						<injectedObject name="param3" type="SharedServices.Interfaces.IInterface3" />
					</parameters>
				</implementation>

				<!--Test injected properties-->
				<implementation type="SharedServices.Implementations.Interface2_Impl2"
								scope="singleton">
					<injectedProperties>
						<!--The value of param2 will be de-serialized using serializer TypeBasedSimpleSerializerDateTime 
                        in parameterSerializers section.-->
						<datetime name="Property1" value="1915-04-24 00:00:00.001" />
						<double name="Property2" value="365.41" />
						<injectedObject name="Property3" type="SharedServices.Interfaces.IInterface3" />
					</injectedProperties>
				</implementation>

				<!--Test constructor parameters with injected properties. Constructor values will be overridden by 
                injected properties.-->
				<implementation type="SharedServices.Implementations.Interface2_Impl3"
								scope="singleton">
					<parameters>
						<!--The value will be de-serialized using serializer TypeBasedSimpleSerializerDateTime in 
                        parameterSerializers section.-->
						<datetime name="param1" value="2017-10-29 23:59:59.099" />
						<double name="param2" value="138.3" />

						<!--
                        Inject specific implementation. Note, there is no binding for Interface3_Impl2. 
                        IoC.Configuration** will automatically register a self bound service for a type specified in elements 
                        injectedObject, if the type is not an abstract type or an interface, and if it is not already 
                        registered in configuration file.
                        Also, using injectedObject, we can specify a type other than a type registered for interface 
                        SharedServices.Implementations.Interface3 (i.e., the type of parameter param3).
                        In other words, no matter what bindings are specified for interface SharedServices.Implementations.Interface3,
                        the object injected for parameter param3 will be of type SharedServices.Implementations.Interface3_Impl2.          
                        -->
						<injectedObject name="param3" type="SharedServices.Implementations.Interface3_Impl2" />
					</parameters>
					<injectedProperties>
						<double name="Property2" value="148.3" />
						<!--
                        Inject specific implementation. Note, there is no binding for Interface3_Impl3. 
                        IoC.Configuration** will automatically register a self bound service for a type specified in element 
                        injectedObject, if the type is not an abstract type or an interface, and if it is not already 
                        registered in configuration file.
                        Also, using injectedObject, we can specify a type other than a type registered for type of property
                        Property3 somewhere else. By using element injectedObject we explicitly state the type of the object
                        that should be injected, which is SharedServices.Implementations.Interface3_Impl3 in this example.
                        -->
						<injectedObject name="Property3" type="SharedServices.Implementations.Interface3_Impl3" />
					</injectedProperties>
				</implementation>

				<!--Test injected constructor parameters. Primitive type constructor parameters, such as DateTime and double,
                    will be injected with default values specified in module: IoC.Configuration.Tests.PrimitiveTypeDefaultBindingsModule.
                 -->
				<implementation type="SharedServices.Implementations.Interface2_Impl4"
								scope="singleton">
				</implementation>
			</service>

			<!--Test constructed values to set implementation constructor parameter and property values-->
			<service type="SharedServices.Interfaces.Airplane.IAirplane" >
				<implementation type="SharedServices.Implementations.Airplane.Airplane" scope="singleton" >
					<parameters>
						<!--Tested constructed value in parameter-->
						<constructedValue name="engine" type="SharedServices.Implementations.Airplane.AirplaneEngine">
							<parameters>
								<!--Constructed value parameters can also be constructed values. However, for simplicity, injected parameters were used -->
								<injectedObject name="blade" type="SharedServices.Interfaces.Airplane.IAirplaneEngineBlade" />
								<injectedObject name="rotor" type="SharedServices.Interfaces.Airplane.IAirplaneEngineRotor" />
							</parameters>
							<!--constructedValue element also can have injectedProperties child element to inject values into constructed object
              properties which have public setters.-->
							<!--<injectedProperties></injectedProperties>-->
						</constructedValue>

					</parameters>
				</implementation>

				<!--Tested constructed value to inject property values-->
				<implementation type="SharedServices.Implementations.Airplane.Airplane" scope="singleton">

					<injectedProperties>
						<!--Injecting constructed value of type SharedServices.Implementations.Airplane.AirplaneEngine 
						into a property SharedServices.Implementations.Airplane.Airplane.Engine-->
						<constructedValue name="Engine" type="SharedServices.Implementations.Airplane.AirplaneEngine">
							<!--Class TestProjects.SharedServices.Implementations.Airplane.AirplaneEngine has a default constructor
							which will be used in this case.-->


							<!--After the object is created, the values of properties AirplaneEngine.Blade and AirplaneEngine.Rotor will 
							be injected using injectedProperties element.-->
							<injectedProperties>

								<!--Constructed value parameters can also be constructed values. However, for simplicity, injected parameters were used -->
								<injectedObject name="Blade" type="SharedServices.Interfaces.Airplane.IAirplaneEngineBlade" />
								<injectedObject name="Rotor" type="SharedServices.Interfaces.Airplane.IAirplaneEngineRotor" />
							</injectedProperties>
						</constructedValue>
					</injectedProperties>
				</implementation>
			</service>

			<service type="SharedServices.Interfaces.Airplane.IAirplaneEngineBlade">
				<implementation  type="SharedServices.Implementations.Airplane.AirplaneEngineBlade" scope="singleton"></implementation>
			</service>
			<service type="SharedServices.Interfaces.Airplane.IAirplaneEngineRotor">
				<implementation  type="SharedServices.Implementations.Airplane.AirplaneEngineRotor" scope="singleton"></implementation>
			</service>

			<!--<selfBoundService type="SharedServices.Implementations.ActionValidator3" scope="transient">
				<parameters>
					<int32 name="intParam" value="5" />
				</parameters>
			</selfBoundService>-->

			<selfBoundService type="DynamicallyLoadedAssembly1.Implementations.CleanupJob2"
							  scope="transient">
				<parameters>
					<injectedObject name="cleanupJobData"
									type="DynamicallyLoadedAssembly1.Implementations.CleanupJobData2" />
				</parameters>
			</selfBoundService>

			<selfBoundService type="DynamicallyLoadedAssembly1.Implementations.CleanupJob3"
							  scope="singleton">
				<injectedProperties>
					<injectedObject name="CleanupJobData"
									type="DynamicallyLoadedAssembly1.Implementations.CleanupJobData2"/>
				</injectedProperties>
			</selfBoundService>

			<service type="SharedServices.Interfaces.ICleanupJobData">
				<implementation type="DynamicallyLoadedAssembly1.Implementations.CleanupJobData"
								scope="singleton">
				</implementation>

			</service>

			<!--Service implemented by plugins-->
			<service type="SharedServices.Interfaces.IInterface5">
				<implementation type="SharedServices.Implementations.Interface5_Impl1"
								scope="singleton" />
				<implementation type="TestPluginAssembly1.Implementations.Interface5_Plugin1Impl"
								scope="singleton" />
				<implementation type="TestPluginAssembly2.Implementations.Interface5_Plugin2Impl"
								scope="transient" />
				<implementation type="TestPluginAssembly3.Implementations.Interface5_Plugin3Impl"
								scope="transient" />
			</service>

			<!--
			Test registerIfNotRegistered. Note, SharedServices.Interfaces.IInterface6 is already registered in
			module  Modules.IoC.DiModule1 for implementation SharedServices.Implementations.Interface6_Impl1.
			Therefore, implementation SharedServices.Implementations.Interface6_Impl2 will not be registered.            
			-->
			<service type="SharedServices.Interfaces.IInterface6"
					 registerIfNotRegistered="true">
				<implementation type="SharedServices.Implementations.Interface6_Impl2"
								scope="singleton" />
			</service>

			<!--
			Note, service SharedServices.Interfaces.IInterface7 was not registered before. Therefore its implementations
			registered below will be registered.
			-->
			<service type="SharedServices.Interfaces.IInterface7"
					 registerIfNotRegistered="true">
				<implementation type="SharedServices.Implementations.Interface7_Impl1"
								scope="singleton" />
			</service>

			<selfBoundService type="SharedServices.Implementations.SelfBoundService1"
							  registerIfNotRegistered="true" scope="singleton">

			</selfBoundService>

			<service type="SharedServices.Interfaces.IInterface12">
				<implementation type="SharedServices.Implementations.Interface12_Impl1" scope="singleton">
					<parameters>
						<!--Setting with name Interface11_Value is injected into constructor parameter param1 of
						class SharedServices.Implementations.Interface12_Impl1-->
						<!--NOTE: For more comprehensive examples for settingValue element,
						look at file IoCConfiguration_settingValue_ReferencingInConfiguration.xml and tests in folder SettingValue.-->
						<settingValue name="param1" settingName="Interface11_Value"/>
					</parameters>
					<injectedProperties>
						<!--Setting with name Interface11_Value is injected into property 
						SharedServices.Implementations.Interface12_Impl1.Property2-->
						<settingValue name="Property2" settingName="Interface11_Value"/>
					</injectedProperties>
				</implementation>

			</service>
			<service type="SharedServices.Interfaces.IDbConnection">
				<valueImplementation scope="singleton">
					<settingValue settingName="DefaultDBConnection"/>
				</valueImplementation>
			</service>

			<!--NOTE: For more comprehensive examples for collection element,
				look at file IoCConfiguration_collection.xml and tests in folder Collection.-->
			<!--NOTE: For more comprehensive examples for valueImplementation element,
				look at file IoCConfiguration_valueImplementation.xml and tests in folder ValueImplementation.-->
			<service type="System.Collections.Generic.IReadOnlyList[SharedServices.Interfaces.IDbConnection]">
				<valueImplementation scope="singleton">
					<collection>
						<settingValue settingName="DefaultDBConnection"/>
						<constructedValue type="SharedServices.Implementations.SqlServerDbConnection">
							<parameters>
								<string name="serverName" value="SQLSERVER2012"/>
								<string name="databaseName" value="DB1"/>
								<string name="userName" value="user1"/>
								<string name="password" value="password123"/>
							</parameters>
						</constructedValue>
						<constructedValue type="SharedServices.Implementations.SqlServerDbConnection">
							<parameters>
								<string name="serverName" value="SQLSERVER2016"/>
								<string name="databaseName" value="DB1"/>
								<string name="userName" value="user1"/>
								<string name="password" value="password123"/>
							</parameters>
						</constructedValue>
					</collection>
				</valueImplementation>
			</service>

			<!--NOTE: For more comprehensive examples for proxyService element,
			look at file IoCConfiguration_proxyService.xml and tests in folder ProxyService.-->
			<!--
			Using proxyService we can configure binding of a parent interface IActionValidatorFactoryBase in such a way, that it is resolved 
			using the same binding set up for extending interface IActionValidatorFactory. 
			For example auto-generated service IActionValidatorFactory implements methods and properties in both IActionValidatorFactory
			as well as in parent interface IActionValidatorFactoryBase. By using proxyService we can inject the auto-generated implementation
			for IActionValidatorFactory into classes which depend on its parent interface IActionValidatorFactoryBase.      
			-->
			<proxyService type="IoC.Configuration.Tests.AutoService.Services.IActionValidatorFactoryBase">
				<serviceToProxy type="IoC.Configuration.Tests.AutoService.Services.IActionValidatorFactory"/>
			</proxyService>

			<!--START-Test binding an interface to the ame instance to which a self-bound class is bound-->
			<selfBoundService type="SharedServices.Implementations.Interface13_Impl1" scope="singleton" />

			<!--NOTE: Using proxyService allows us to bind 
            SharedServices.Interfaces.IInterface13 to the same instance of SharedServices.Implementations.Interface13_Impl1 to which
            SharedServices.Implementations.Interface13_Impl1 was bound using selfBoundService element.
            
            If we used "implementation" element under service and specified a type SharedServices.Implementations.Interface13_Impl1
            instead of using "proxyService", then SharedServices.Interfaces.IInterface13 would have been 
            bound to a different instance of SharedServices.Implementations.Interface13_Impl1. In other words resolving
            SharedServices.Implementations.Interface13_Impl1 and SharedServices.Interfaces.IInterface13 would have resulted in 
            different instances of SharedServices.Implementations.Interface13_Impl1.
            Using "proxyService" element might be useful when we have module(s) that scan assemblies and self-binds 
            non-abstract classes. In this cases we can use "proxyService" element if we want the interface
            specified in "proxyService" element to resolve to exactly the same value to which the self bound class is bound.
            -->
			<proxyService type="SharedServices.Interfaces.IInterface13">
				<serviceToProxy type="SharedServices.Implementations.Interface13_Impl1"/>
			</proxyService>

			<service type="SharedServices.Interfaces.IInterface14">
				<implementation type="SharedServices.Implementations.Interface14_Impl1" scope="singleton" />
			</service>

			<!--END-Test binding an interface to the ame instance to which a self-bound class is bound-->

			<!--Note, ActionValidatorsUser constructor has a parameter of type 
			IoC.Configuration.Tests.AutoService.Services.IActionValidatorFactoryBase. 
			Since there is a proxyService element mapping the service IActionValidatorFactoryBase to IActionValidatorFactory,
			an instance of auto-generated service IoC.Configuration.Tests.AutoService.Services.IActionValidatorFactory will be injected.      
			-->
			<selfBoundService type="IoC.Configuration.Tests.ProxyService.Services.ActionValidatorsUser" scope="singleton">
			</selfBoundService>

			<!--System.Collections.Generic.List<System.Int32> will be bound to a list of three integers: 19, 2, 17-->
			<service typeRef="ListOfInt">
				<valueImplementation scope="singleton">
					<collection>
						<int32 value="19"/>
						<int32 value="2"/>
						<int32 value="17"/>
					</collection>
				</valueImplementation>
			</service>

			<!--Resolving System.Collections.Generic.IEnumerable<System.Int32> will return the same value as resolving 
            System.Collections.Generic.List<System.Int32>-->
			<proxyService type="System.Collections.Generic.IEnumerable[System.Int32]">
				<serviceToProxy typeRef="ListOfInt"/>
			</proxyService>

			<!--Resolving System.Collections.Generic.IReadOnlyList<System.Int32> will return the same value as resolving 
            System.Collections.Generic.List<System.Int32>-->
			<proxyService type="System.Collections.Generic.IReadOnlyList[System.Int32]">
				<serviceToProxy typeRef="ListOfInt"/>
			</proxyService>

			<!--Resolving System.Collections.Generic.IList<System.Int32> will return the same value as resolving 
            System.Collections.Generic.List<System.Int32>-->
			<proxyService type="System.Collections.Generic.IList[System.Int32]">
				<serviceToProxy typeRef="ListOfInt"/>
			</proxyService>

			<!--      
			Demo of classMember element to use static or non-static variables, properties and result of a call to parameterless
			method to generate value used in configuration file.
			NOTE: For more comprehensive examples for classMember element and "_classMember:" prefix in attributes in "if" elements in 
			autoService element, look at file IoCConfiguration_classMember.xml and tests in folder ClassMember.
			-->
			<service type="System.Collections.Generic.IReadOnlyList[IoC.Configuration.Tests.ClassMember.Services.IAppInfo]">
				<valueImplementation scope="singleton">
					<collection>
						<constructedValue type="IoC.Configuration.Tests.ClassMember.Services.AppInfo">
							<parameters>
								<!--We inject the constant value IoC.Configuration.Tests.ClassMember.Services.ConstAndStaticAppIds.AppId1
								into constructor of AppInfo for parameter appId.
								We can also use non constant static variables, as well as static properties and parameterless methods.
								-->
								<classMember name="appId"
											 class="IoC.Configuration.Tests.ClassMember.Services.ConstAndStaticAppIds"
											 memberName="AppId1"/>
							</parameters>
						</constructedValue>
						<constructedValue type="IoC.Configuration.Tests.ClassMember.Services.AppInfo">
							<injectedProperties>
								<!--Since SharedServices.Implementations.SelfBoundService1.IntValue is a non-static property,
								an instance of SharedServices.Implementations.SelfBoundService1 will be resolved from the DI container,
								and the value of IntValue of resolved instance will be injected into property AppInfo.AppId.
								Note, we can also use parameterless methods.
								Also, if the class in class attribute is non-interface, non-abstract, and has a public constructor,
								IoC.Configuration will generated a binding for that class, if one is not specified in configuration file
								or IoC.Configuration modules.
								-->
								<classMember name="AppId"  class="SharedServices.Implementations.SelfBoundService1"
											 memberName="IntValue"/>
							</injectedProperties>
						</constructedValue>

						<constructedValue type="IoC.Configuration.Tests.ClassMember.Services.AppInfo">
							<parameters>
								<!--The enum value IoC.Configuration.Tests.ClassMember.Services.AppTypes.App1 is injected into constructor of 
								AppInfo for parameter appId-->
								<classMember name="appId"
											 class="IoC.Configuration.Tests.ClassMember.Services.AppTypes"
											 memberName="App1"/>
							</parameters>
						</constructedValue>

						<!--
						An example of calling a non static factory method to create an instance of IAppInfo.             
						Since method IoC.Configuration.Tests.ClassMember.Services.IAppInfoFactory.CreateAppInfo(appId, appDescription)
						is non-static, an instance of IAppInfoFactory will be resolved using the DI container.
						Also, since IAppInfoFactory is an interface, a binding for IAppInfoFactory should be configured in configuration
						file or in some module.
						-->
						<classMember class="IoC.Configuration.Tests.ClassMember.Services.IAppInfoFactory" memberName="CreateAppInfo">
							<parameters>
								<int32 name="appId" value="1258"/>
								<string name="appDescription" value="App info created with non-static method call."/>
							</parameters>
						</classMember>

						<!--
						An example of calling a static factory method to create an instance of IAppInfo.
						-->
						<classMember class="IoC.Configuration.Tests.ClassMember.Services.StaticAppInfoFactory" memberName="CreateAppInfo">
							<parameters>
								<int32 name="appId" value="1259"/>
								<string name="appDescription" value="App info created with static method call."/>
							</parameters>
						</classMember>
					</collection>
				</valueImplementation>
			</service>

			<service type="IoC.Configuration.Tests.ClassMember.Services.IAppInfoFactory">
				<implementation type="IoC.Configuration.Tests.ClassMember.Services.AppInfoFactory" scope="singleton"/>
			</service>

			
		</services>

		<autoGeneratedServices>
			<!--NOTE: For more comprehensive examples for autoService element, look at 
			file IoCConfiguration_autoService.xml and tests in folder AautoService.-->

			<!--The scope for autoService implementations is always singleton -->
			<autoService interfaceRef="IProjectGuids" >

				<!--Note, since property Project1 in IoC.Configuration.Tests.AutoService.Services.IProjectGuids has
				a setter, the implementation will implement the setter as well.-->
				<autoProperty name="Project1" returnTypeRef="Guid">
					<object typeRef="Guid" value="966FE6A6-76AC-4895-84B2-47E27E58FD02"/>
				</autoProperty>

				<autoProperty name="Project2" returnTypeRef="Guid">
					<object typeRef="Guid" value="AC4EE351-CE69-4F89-A362-F833489FD9A1"/>
				</autoProperty>

				<autoMethod name="GetDefaultProject" returnTypeRef="Guid">
					<!--No methodSignature is required, since the method does not have any parameters.-->
					<default>
						<!--TODO: change the returned value to classMember which references IProjectGuids.Project1 -->
						<object typeRef="Guid" value="1E08071B-D02C-4830-AE3C-C9E78A29EA37"/>

					</default>
				</autoMethod>

			<!---IoC.Configuration.Tests.AutoService.Services.IProjectGuids also has a method NotImplementedMethod()
			which will be auto-implemented as well.-->
			</autoService>

			<!--Demo of referencing auto-implemented method parameters using parameterValue element-->
			<autoService interface="IoC.Configuration.Tests.AutoService.Services.IAppInfoFactory">
				<autoMethod name="CreateAppInfo" returnType="IoC.Configuration.Tests.AutoService.Services.IAppInfo">
					<methodSignature>
						<int32 paramName="appId"/>
						<string paramName="appDescription"/>
					</methodSignature>

					<default>
						<constructedValue type="IoC.Configuration.Tests.AutoService.Services.AppInfo">
							<parameters>
								<!--The value of name attribute is the name of constructor parameter in AppInfo-->
								<!--
								The value of paramName attribute is the name of parameter in IAppInfoFactory.CreateAppInfo.
								This parameter should be present under autoMethod/methodSignature element.
								-->
								<!--In this example the values of name and paramName are similar, however they don't 
								have to be.-->
								<parameterValue name="appId" paramName="appId" />
								<parameterValue name="appDescription" paramName="appDescription" />
							</parameters>
						</constructedValue>
					</default>
				</autoMethod>
			</autoService>

			<!--The scope for autoService implementations is always singleton -->
			<autoService interface="IoC.Configuration.Tests.AutoService.Services.IActionValidatorFactory">

				<autoProperty name="DefaultActionValidator" returnType="SharedServices.Interfaces.IActionValidator">
					<injectedObject type="IoC.Configuration.Tests.AutoService.Services.ActionValidatorDefault"/>
				</autoProperty>

				<autoProperty name="PublicProjectId" returnType="System.Guid" >
					<object type="System.Guid" value="95E352DD-5C79-49D0-BD51-D62153570B61"/>
				</autoProperty>

				<autoMethod name="GetValidators"
							returnType="System.Collections.Generic.IReadOnlyList[SharedServices.Interfaces.IActionValidator]"
							reuseValue="true">

					<methodSignature>
						<!--paramName attribute is optional, however it makes the auto-implementation more readable. -->
						<object paramName="actionType" typeRef="ActionTypes"/>
						<object paramName="projectGuid" type="System.Guid"/>
					</methodSignature>

					<!--Parameter actionType (parameter1) value: In this example we use class member ViewFilesList (enum value) in enumeration 
					SharedServices.DataContracts.ActionTypes. Note, we use alias ActionTypes to reference the enum type declared in typeDefinitions section.
					-->
					<!--Parameter projectGuid (parameter2) value: The string "F79C3F23-C63F-4EB0-A513-7A8772A82B35" will be de-serialized to a System.Guid value,
					using the default OROptimizer.Serializer.TypeBasedSimpleSerializerGuid serializer. More serializers can be provided in section 
					parameterSerializers-->
					<if parameter1="_classMember:ActionTypes.ViewFilesList" parameter2="8663708F-C707-47E1-AEDC-2CD9291AD4CB">
						<collection>
							<constructedValue type="SharedServices.Implementations.ActionValidator3">
								<parameters>
									<int32 name="intParam" value="7"/>
								</parameters>
							</constructedValue>

							<!--Constructor of ActionValidatorWithDependencyOnActionValidatorFactory has a parameter of type 
							IoC.Configuration.Tests.AutoService.Services.IActionValidatorFactory. Therefore an instance of auto-generated service  IActionValidatorFactory
							will be injected.
							-->
							<injectedObject type="IoC.Configuration.Tests.AutoService.Services.ActionValidatorWithDependencyOnActionValidatorFactory"/>

							<constructedValue type=" IoC.Configuration.Tests.AutoService.Services.ActionValidator1" >
								<parameters>
									<injectedObject name="param1" typeRef="AutoService_IInterface1" />
								</parameters>
								<injectedProperties>
									<!-- Note, we could have used constructedValue element to inject a constructed value into property
									ActionValidator1.Property2. However, to keep the example simple, injectedObject was used -->
									<injectedObject name="Property2" type="IoC.Configuration.Tests.AutoService.Services.IInterface2" />
								</injectedProperties>
							</constructedValue>

							<injectedObject type="TestPluginAssembly1.Implementations.Plugin1ActionValidator"/>

							<classMember class="IoC.Configuration.Tests.AutoService.Services.StaticAndConstMembers" memberName="ActionValidator1" />

							<!--Since DefaultActionValidator property in IoC.Configuration.Tests.AutoService.Services.IActionValidatorValuesProvider interface is 
							not static, IoC.Configuration.Tests.AutoService.Services.IActionValidatorValuesProvider will be injected. 
							Therefore, a binding should be setup for this class (or the interface should be auto-implemented 
							using autoService element)
							-->
							<classMember class="IoC.Configuration.Tests.AutoService.Services.IActionValidatorValuesProvider"
										 memberName="DefaultActionValidator"/>

							<!--Since Plugin3 is disabled, Plugin3ActionValidator will be ignored -->
							<injectedObject type="TestPluginAssembly3.Implementations.Plugin3ActionValidator"/>
						</collection>
					</if>

					<!--Parameter actionType (parameter1) value: In this example we use full class path for 
					SharedServices.DataContracts.ActionTypes in parameter1, instead of referencing a type declared in typeDefinitions element.
					-->
					<!--Parameter projectGuid (parameter2) value: In this case we reference the Project1Guid setting value in settings section, instead
					of using a Guid string-->
					<if parameter1="_classMember:ActionTypes.ViewFileContents" parameter2="_settings:Project1Guid">
						<collection>
							<!--Since IoC.Configuration.Tests.AutoService.Services.ActionValidator1 and SharedServices.Implementations.ActionValidator2 are
							concrete (non-interface and non-abstract) classes), and have public constructors,
							self bound service bindings for these classes will be automatically added, if binding for these classes are not specified
							in configuration file or in some module of type IoC.Configuration.DiContainer.IDiModule -->

							<injectedObject type="IoC.Configuration.Tests.AutoService.Services.ActionValidator1" />

							<!--Since GetViewOnlyActionvalidator() method in IoC.Configuration.Tests.AutoService.Services.IActionValidatorValuesProvider 
							interface is not static, IoC.Configuration.Tests.AutoService.Services.IActionValidatorValuesProvider will be injected. 
							Therefore, a binding should be setup for this class (or the interface should be auto-implemented using 
							autoService element).
							-->
							<classMember class="IoC.Configuration.Tests.AutoService.Services.IActionValidatorValuesProvider"
										 memberName="GetViewOnlyActionvalidator"/>
						</collection>
					</if>

					<!--Parameter actionType (parameter1) value: In this case we use constant value DefaultActionType declared in 
					class IoC.Configuration.Tests.AutoService.Services.StaticAndConstMembers.
					-->
					<!--Parameter projectGuid (parameter2) value: In this case we use the value of property Project1 in 
					IoC.Configuration.Tests.AutoService.Services.IProjectGuids. Since the property Project1 is not static, 
					class IoC.Configuration.Tests.AutoService.Services.IProjectGuids will be injected.
					-->
					<if parameter1="_classMember:IoC.Configuration.Tests.AutoService.Services.StaticAndConstMembers.DefaultActionType"
						parameter2="_classMember:IProjectGuids.Project1">
						<collection>
							<!--Lets assume no validators are needed for this case-->
						</collection>
					</if>

					<!--Parameter actionType (parameter1) value: In this case we use enum value 
					SharedServices.DataContracts.ActionTypes.ViewFileContents. We use a shortcut (an alias) ActionTypes to reference a 
					reference the class SharedServices.DataContracts.ActionTypes declared in typeDefintions section.
					-->
					<!--Parameter projectGuid (parameter2) value: In this case we use the value returned by a call to static method 
					GetDefaultProjectGuid() in class IoC.Configuration.Tests.AutoService.Services.StaticAndConstMembers.
					-->
					<if parameter1="_classMember:ActionTypes.ViewFileContents"
						parameter2="_classMember:IoC.Configuration.Tests.AutoService.Services.StaticAndConstMembers.GetDefaultProjectGuid">

						<!--Continue here.-->
						<collection>
							<!--Since IoC.Configuration.Tests.AutoService.Services.ActionValidator1 and SharedServices.Implementations.ActionValidator2 are
							concrete (non-interface and non-abstract classes), and have public constructors,
							self bound service bindings for these classes will be automatically added, if binding for these classes 
							are not specified in configuration file or in some module of type IoC.Configuration.DiContainer.IDiModule -->

							<injectedObject type="SharedServices.Implementations.ActionValidator2" />
							<injectedObject type="IoC.Configuration.Tests.AutoService.Services.ActionValidator1" />
						</collection>
					</if>

					<!--Note parameter2 references PublicProjectId property in this 
					auto-generated IoC.Configuration.Tests.AutoService.Services.IActionValidatorFactory service. -->
					<if parameter1="_classMember:ActionTypes.ViewFilesList"
						parameter2="_classMember:IoC.Configuration.Tests.AutoService.Services.IActionValidatorFactory.PublicProjectId">
						<collection>
							<!--Note, we can reference a property in this auto-generated 
							IoC.Configuration.Tests.AutoService.Services.IActionValidatorFactory service.-->
							<classMember class="IoC.Configuration.Tests.AutoService.Services.IActionValidatorFactory" memberName="DefaultActionValidator"/>
						</collection>

					</if>

					<!--if none of conditions above are true, the default value will be returned by interface implementation.-->
					<default>
						<collection>
							<!--We can also call a method or property in auto-generated interface, or in one of its base interfaces.-->
							<classMember class="IoC.Configuration.Tests.AutoService.Services.IActionValidatorFactory" memberName="DefaultActionValidator"/>
							<injectedObject type="SharedServices.Implementations.ActionValidator3" />
							<injectedObject type="DynamicallyLoadedAssembly2.ActionValidator4"/>
						</collection>
					</default>
				</autoMethod>

				<!--Overloaded method GetValidators uses parameters of types System.Int2 and System.string, instead of
				SharedServices.DataContracts.ActionTypes and System.Guid, as in case above.-->
				<autoMethod name="GetValidators"
							returnType="System.Collections.Generic.IReadOnlyList[SharedServices.Interfaces.IActionValidator]">
					<methodSignature>
						<!--paramName attribute is optional, however it makes the auto-implementation more readable. -->
						<int32 paramName="actionTypeId"/>
						<string paramName="projectGuid" />
					</methodSignature>

					<!-- Attributes parameter1 and parameter2 map values of parameters param1 and param2 in GetInstances() method to returned values. -->
					<if parameter1="0" parameter2="8663708F-C707-47E1-AEDC-2CD9291AD4CB">
						<collection>
							<injectedObject type="SharedServices.Implementations.ActionValidator3" />
							<injectedObject type="IoC.Configuration.Tests.AutoService.Services.ActionValidator4" />
						</collection>
					</if>

					<default>
						<collection>
							<!--We can also call a method or property in auto-generated interface, or in one of its base interfaces.-->
							<classMember class="IoC.Configuration.Tests.AutoService.Services.IActionValidatorFactory"
										 memberName="DefaultActionValidator"/>
							<injectedObject type="SharedServices.Implementations.ActionValidator3" />
							<classMember class="IoC.Configuration.Tests.AutoService.Services.StaticAndConstMembers"
										 memberName="GetDefaultActionValidator" />
							<classMember class="IoC.Configuration.Tests.AutoService.Services.IActionValidatorValuesProvider"
										 memberName="AdminLevelActionValidator"/>
						</collection>
					</default>
				</autoMethod>

			<!--Note, interface IoC.Configuration.Tests.AutoService.Services.IActionValidatorFactory also has a method 
			void SomeMethodThatWillNotBeImplemented(int param1, string param2) and a property int SomeUnImplementedProperty { get; },'
			we chose not to implement in configuration file. Unimplemented methods and properties will be auto-implemented to return default values,
			based on return type defaults.        
			-->
			</autoService>

			<!--IMemberAmbiguityDemo demonstrates cases when there are multiple occurrences
			of auto-generated methods and properties with same signatures and return types 
			in IMemberAmbiguityDemo and its base interfaces.
			-->
			<autoService interface="IoC.Configuration.Tests.AutoService.Services.IMemberAmbiguityDemo">
				<!--GetIntValues(): IReadOnlyList<int> GetIntValues(int param1, string param2)-->
				<autoMethod name="GetIntValues" returnType="System.Collections.Generic.IReadOnlyList[System.Int32]" >
					<methodSignature>
						<int32 paramName="param1"/>
						<string paramName="param2"/>
					</methodSignature>
					<if parameter1="1" parameter2="str1">
						<collection>
							<int32 value="17"/>
						</collection>
					</if>
					<default>
						<collection>
							<int32 value="18"/>
							<int32 value="19"/>
						</collection>
					</default>
				</autoMethod>

				<!--
				This method is declared in IMemberAmbiguityDemo_Parent3, which is a base interface for IMemberAmbiguityDemo.
				We can provide implementation for this interface, even though it has a similar signature and return type as the method 
				method IoC.Configuration.Tests.AutoService.Services.IMemberAmbiguityDemo.GetIntValues.
				By using the attribute 'declaringInterface', we make a distinction between these two.
				-->
				<autoMethod name="GetIntValues" returnType="System.Collections.Generic.IReadOnlyList[System.Int32]"
							declaringInterface="IoC.Configuration.Tests.AutoService.Services.IMemberAmbiguityDemo_Parent3">
					<methodSignature>
						<int32 paramName="param1"/>
						<string paramName="param2"/>
					</methodSignature>
					<default>
						<collection>
							<int32 value="3"/>
						</collection>
					</default>
				</autoMethod>

				<!---
				The method GetDbConnection(System.Guid appGuid) that return IDbConnection is in two base interfaces
				of IMemberAmbiguityDemo: in IoC.Configuration.Tests.AutoService.Services.IMemberAmbiguityDemo_Parent1 and in
				IoC.Configuration.Tests.AutoService.Services.IMemberAmbiguityDemo_Parent2.
				Therefore, to avoid ambiguity, we have to specify the declaring interface in attribute 'declaringInterface'.
				We can specify an implementation for IoC.Configuration.Tests.AutoService.Services.IMemberAmbiguityDemo_Parent2.GetDbConnection(),
				and IoC.Configuration will generate a similar auto-implementation for the similar method in IMemberAmbiguityDemo_Parent1
				as well.        
				-->
				<autoMethod name="GetDbConnection" returnType="SharedServices.Interfaces.IDbConnection"
							declaringInterface="IoC.Configuration.Tests.AutoService.Services.IMemberAmbiguityDemo_Parent2">
					<methodSignature>
						<object paramName="appGuid" type="System.Guid"/>
					</methodSignature>
					<default>
						<constructedValue type="SharedServices.Implementations.SqliteDbConnection">
							<parameters>
								<string name="filePath" value="c:\mySqliteDatabase.sqlite"/>
							</parameters>
						</constructedValue>
					</default>
				</autoMethod>

				<!--
				Both IMemberAmbiguityDemo_Parent1 and IMemberAmbiguityDemo_Parent2 have properties called DefaultDbConnection
				with the same return types. We can auto-implement this property for each of these interfaces by using 
				declaringInterface attribute in autoProperty element to explicitly specify the interface that own 
				the property (declaringInterface can be used in autoMethod as well as demonstrated above)
				-->
				<!--Auto-implementation of IMemberAmbiguityDemo_Parent1.DefaultDbConnection-->
				<autoProperty name="DefaultDbConnection" returnType="SharedServices.Interfaces.IDbConnection"
							  declaringInterface="IoC.Configuration.Tests.AutoService.Services.IMemberAmbiguityDemo_Parent1">
					<constructedValue type="SharedServices.Implementations.SqliteDbConnection">
						<parameters>
							<string name="filePath" value="c:\IMemberAmbiguityDemo_Parent1_Db.sqlite"/>
						</parameters>
					</constructedValue>
				</autoProperty>

				<!--Auto-implementation of IMemberAmbiguityDemo_Parent2.DefaultDbConnection-->
				<autoProperty name="DefaultDbConnection" returnType="SharedServices.Interfaces.IDbConnection"
							  declaringInterface="IoC.Configuration.Tests.AutoService.Services.IMemberAmbiguityDemo_Parent2">
					<constructedValue type="SharedServices.Implementations.SqliteDbConnection">
						<parameters>
							<string name="filePath" value="c:\IMemberAmbiguityDemo_Parent2_Db.sqlite"/>
						</parameters>
					</constructedValue>
				</autoProperty>

				<!--
				Method GetNumericValue() occurs in both IoC.Configuration.Tests.AutoService.Services.IMemberAmbiguityDemo_Parent2
				and IoC.Configuration.Tests.AutoService.Services.IMemberAmbiguityDemo_Parent1_Parent. However, since the return types 
				are different (System.Double in IMemberAmbiguityDemo_Parent2, and System.Int32 in IMemberAmbiguityDemo_Parent1_Parent),
				we can auto-implement both them, without using attribute 'declaringInterface' to separate these two implementation.
				-->
				<!--IMemberAmbiguityDemo_Parent2.GetNumericValue() with return type of System.Double-->
				<autoMethod name="GetNumericValue" returnType="System.Double" >
					<default>
						<double value="17.3"/>
					</default>
				</autoMethod>

				<!--IMemberAmbiguityDemo_Parent1_Parent.GetNumericValue() with return type of System.Int32-->
				<autoMethod name="GetNumericValue" returnType="System.Int32" >
					<default>
						<int32 value="19"/>
					</default>
				</autoMethod>

				<!--
				Property NumericValue occurs in both IoC.Configuration.Tests.AutoService.Services.IMemberAmbiguityDemo_Parent1
				and IoC.Configuration.Tests.AutoService.Services.IMemberAmbiguityDemo_Parent2. However, since the return types 
				are different (System.Double in IMemberAmbiguityDemo_Parent1, and System.Int32 in IMemberAmbiguityDemo_Parent2),
				we can auto-implement both them, without using attribute 'declaringInterface' to separate these two implementation.
				-->
				<!--IMemberAmbiguityDemo_Parent1.NumericValue with return type of System.Double-->
				<autoProperty name="NumericValue" returnType="System.Double" >
					<double value="18.2"/>
				</autoProperty>

				<!--IMemberAmbiguityDemo_Parent2.NumericValue with return type of System.Int32-->
				<autoProperty name="NumericValue" returnType="System.Int32" >
					<int32 value="14"/>
				</autoProperty>

				<!---Auto-implementing Method with optional parameters: 
				int MethodWithOptionalParameters(int param1, double param2 = 3.5, int param3=7); -->
				<autoMethod name="MethodWithOptionalParameters" returnType="System.Int32">
					<methodSignature>
						<int32 paramName="param1"/>
						<double paramName="param2"/>
						<int32 paramName="param3"/>
					</methodSignature>
					<if parameter1="3" parameter2="3.5" parameter3="7">
						<int32 value="17"/>
					</if>
					<default>
						<int32 value="18"/>
					</default>
				</autoMethod>
			</autoService>

			<!--Interface specified in autoServiceCustom is auto-implemented by implementation of 
			IoC.Configuration.ConfigurationFile.ICustomAutoServiceCodeGenerator IoC.Configuration.Tests.AutoServiceCustom.SimpleDataRepository.RepositoryInterfaceImplementationGenerator
			that is specified in autoServiceCodeGenerator element.-->
			<autoServiceCustom interface="IoC.Configuration.Tests.AutoServiceCustom.SimpleDataRepository.DataRepositories.IAuthorsRepository">
				<autoServiceCodeGenerator>
					<constructedValue type="IoC.Configuration.Tests.AutoServiceCustom.SimpleDataRepository.RepositoryInterfaceImplementationGenerator">
						<parameters>
							<int32 name="someDemoConstructorParameter" value="15" />
						</parameters>
					</constructedValue>
				</autoServiceCodeGenerator>
			</autoServiceCustom>

			<autoServiceCustom interface="IoC.Configuration.Tests.AutoServiceCustom.SimpleDataRepository.DataRepositories.IBooksRepository">
				<autoServiceCodeGenerator>
					<constructedValue type="IoC.Configuration.Tests.AutoServiceCustom.SimpleDataRepository.RepositoryInterfaceImplementationGenerator">
						<parameters>
							<int32 name="someDemoConstructorParameter" value="25" />
						</parameters>
					</constructedValue>
				</autoServiceCodeGenerator>
			</autoServiceCustom>

			<autoServiceCustom interface="IoC.Configuration.Tests.AutoServiceCustom.SimpleDataRepository.DataRepositories.IAuthorBooksRepository">
				<autoServiceCodeGenerator>
					<constructedValue type="IoC.Configuration.Tests.AutoServiceCustom.SimpleDataRepository.RepositoryInterfaceImplementationGenerator">
						<parameters>
							<int32 name="someDemoConstructorParameter" value="35" />
						</parameters>
					</constructedValue>
				</autoServiceCodeGenerator>
			</autoServiceCustom>
		</autoGeneratedServices>
	</dependencyInjection>

	<startupActions>
		<startupAction type="DynamicallyLoadedAssembly1.Implementations.StartupAction1">
			<!--Use parameters element to specify constructor parameters if necessary.-->
			<!--<parameters></parameters>-->
			<!--Use injectedProperties element to inject properties into startup action if necessary.-->
			<!--<injectedProperties></injectedProperties>-->
		</startupAction>
		<startupAction type="DynamicallyLoadedAssembly1.Implementations.StartupAction2">
		</startupAction>
	</startupActions>

	<pluginsSetup>
		<pluginSetup plugin="Plugin1">
			<!--The type in pluginImplementation should be non-abstract class 
                that implements IoC.Configuration.IPlugin and which has a public constructor-->
			<pluginImplementation type="TestPluginAssembly1.Implementations.Plugin1">
				<parameters>
					<int64 name="param1" value="25" />
				</parameters>
				<injectedProperties>
					<int64 name="Property2" value="35"/>
				</injectedProperties>
			</pluginImplementation>
			<settings>
				<int32 name="Int32Setting1" value="25" />
				<int64 name="Int64Setting1" value="38" />
				<string name="StringSetting1" value="String Value 1" />
			</settings>

			<webApi>
				<controllerAssemblies>
					<!--
                      Specify assemblies with API controllers.
                      The user of IoC.Configuration should add the assemblies to MVC using 
                      IMvcBuilder.AddApplicationPart(System.Reflection.Assembly)
                    -->
					<controllerAssembly assembly="pluginassm1" />
					<controllerAssembly assembly="plugin1api" />
				</controllerAssemblies>
			</webApi>
			<dependencyInjection>
				<modules>
					<module type="ModulesForPlugin1.Ninject.NinjectModule1">
						<parameters>
							<int32 name="param1" value="101" />
						</parameters>
					</module>

					<module type="ModulesForPlugin1.Autofac.AutofacModule1" >
						<parameters>
							<int32 name="param1" value="102" />
						</parameters>
					</module>

					<module type="ModulesForPlugin1.IoC.DiModule1" >
						<parameters>
							<int32 name="param1" value="103" />
						</parameters>
					</module>
				</modules>
				<services>
					<service type="TestPluginAssembly1.Interfaces.IDoor">
						<implementation type="TestPluginAssembly1.Implementations.Door"
										scope="transient">
							<parameters>
								<int32 name="Color" value="3" />
								<double name="Height" value="180" />
							</parameters>
						</implementation>
					</service>
					<service type="TestPluginAssembly1.Interfaces.IRoom">
						<implementation type="TestPluginAssembly1.Implementations.Room"
										scope="transient">
							<parameters>
								<object name="door1" type="TestPluginAssembly1.Interfaces.IDoor"
										value="5,185.1" />
								<injectedObject name="door2" type="TestPluginAssembly1.Interfaces.IDoor" />
							</parameters>
							<injectedProperties>
								<object name="Door2" type="TestPluginAssembly1.Interfaces.IDoor"
										value="7,187.3" />
							</injectedProperties>
						</implementation>
					</service>
				</services>
				<autoGeneratedServices>
					<!--The scope for autoService implementations is always singleton -->
					<autoService interface="TestPluginAssembly1.Interfaces.IResourceAccessValidatorFactory">
						<autoMethod name="GetValidators"
									returnType="System.Collections.Generic.IEnumerable[TestPluginAssembly1.Interfaces.IResourceAccessValidator]"
									reuseValue="true" >
							<methodSignature>
								<string paramName="resourceName"/>
							</methodSignature>
							<if parameter1="public_pages">
								<collection>
									<injectedObject type="TestPluginAssembly1.Interfaces.ResourceAccessValidator1"/>
								</collection>

							</if>
							<if parameter1="admin_pages">
								<collection>
									<injectedObject type="TestPluginAssembly1.Interfaces.ResourceAccessValidator1"/>
									<injectedObject type="TestPluginAssembly1.Interfaces.ResourceAccessValidator2"/>
								</collection>
							</if>
							<default>
								<collection>
									<injectedObject type="TestPluginAssembly1.Interfaces.ResourceAccessValidator2"/>
									<injectedObject type="TestPluginAssembly1.Interfaces.ResourceAccessValidator1"/>
								</collection>
							</default>
						</autoMethod>
					</autoService>
				</autoGeneratedServices>
			</dependencyInjection>
		</pluginSetup>

		<pluginSetup plugin="Plugin2">
			<pluginImplementation type="TestPluginAssembly2.Implementations.Plugin2">
				<parameters>
					<boolean name="param1" value="true" />
					<double name="param2" value="25.3" />
					<string name="param3" value="String value" />
				</parameters>
				<injectedProperties>
					<double name="Property2" value="5.3" />
				</injectedProperties>
			</pluginImplementation>
			<settings>
			</settings>

			<dependencyInjection>
				<modules>
				</modules>
				<services>
					<service type="TestPluginAssembly2.Interfaces.IWheel">
						<implementation type="TestPluginAssembly2.Implementations.Wheel"
										scope="transient">
							<parameters>
								<int32 name="Color" value="5" />
								<double name="Height" value="48" />
							</parameters>
						</implementation>
					</service>
					<service type="TestPluginAssembly2.Interfaces.ICar">
						<implementation type="TestPluginAssembly2.Implementations.Car"
										scope="transient">
							<parameters>
								<object name="wheel1" type="TestPluginAssembly2.Interfaces.IWheel" value="248,40" />
							</parameters>
							<injectedProperties>
								<object name="Wheel1" type="TestPluginAssembly2.Interfaces.IWheel" value="27,45" />
								<injectedObject name="Wheel2" type="TestPluginAssembly2.Interfaces.IWheel"/>
							</injectedProperties>
						</implementation>
					</service>
				</services>
				<autoGeneratedServices>

				</autoGeneratedServices>
			</dependencyInjection>
		</pluginSetup>

		<pluginSetup plugin="Plugin3">
			<pluginImplementation type="TestPluginAssembly3.Implementations.Plugin3">
			</pluginImplementation>
			<settings></settings>
			<webApi>
				<controllerAssemblies>
					<!--
					Specify assemblies with API controllers.
					The user of IoC.Configuration should add the assemblies to MVC using 
					IMvcBuilder.AddApplicationPart(System.Reflection.Assembly)
					-->
					<controllerAssembly assembly="pluginassm3" />
				</controllerAssemblies>
			</webApi>
			<dependencyInjection>
				<modules>
				</modules>
				<services>
				</services>
				<autoGeneratedServices>
				</autoGeneratedServices>
			</dependencyInjection>
		</pluginSetup>
	</pluginsSetup>
</iocConfiguration>

```

## Code Based Configuration

Code based configuration is pretty similar to file based configuration, except there is no configuration file. 
All dependencies are bound in IoC.Configuration modules (i.e., instances IoC.Configuration.DiContainer.IDiModule) native modules (e.g., instances of  Autofac.AutofacModule or Ninject.Modules.NinjectModule)

Here is an example of code based configuration.

```csharp

TestsSharedLibrary.TestsHelper.SetupLogger();

// Probing paths are used to re-solve the dependencies.
var assemblyProbingPaths = new string[]
{
    DiManagerHelpers.ThirdPartyLibsFolder,
    DiManagerHelpers.DynamicallyLoadedDllsFolder,
    DiManagerHelpers.GetDiImplementationInfo(DiImplementationType.Autofac).DiManagerFolder
};

var diImplementationInfo = DiManagerHelpers.GetDiImplementationInfo(DiImplementationType.Autofac);

using (var containerInfo = 
        new DiContainerBuilder.DiContainerBuilder()
                .StartCodeBasedDi("IoC.Configuration.Autofac.AutofacDiManager",
                                  diImplementationInfo.DiManagerAssemblyPath,
                                  new ParameterInfo[0],
                                  Helpers.TestsEntryAssemblyFolder,
                                  assemblyProbingPaths)
                .WithoutPresetDiContainer()
                // Note, AddNativeModule() to add native modules (e.g., instances of  Autofac.AutofacModule or
                // Ninject.Modules.NinjectModule) // and AddDiModules to add IoC.Configuration modules (i.e.,
                // instances IoC.Configuration.DiContainer.IDiModule), can be called multiple times, without
                // any restriction on the order in which these methods are called.           
                .AddNativeModule("Modules.Autofac.AutofacModule1",
                                 Path.Combine(DiManagerHelpers.DynamicallyLoadedDllsFolder, "TestProjects.Modules.dll"), 
                                 new[] { new ParameterInfo(typeof(int), 18) })
                .AddDiModules(new TestDiModule())
                .RegisterModules()
                .Start())
{
    var container = containerInfo.DiContainer;
    Assert.IsNotNull(containerInfo.DiContainer.Resolve<IInterface6>());
}
```

## Native and IoC.Configuration modules in configuration file.

Both native modules (e.g., subclasses of Autofac.AutofacModule or Ninject.Modules.NinjectModule) and IoC.Configuration modules can be specified in configuration files. 

Here is an example from configuration file above which has both native and container agnostic IoC.Configuration modules.

![](http://oroptimizer.com/IoC.Configuration/GitHubDocs/NativeModulesInConfigurationFile.png)