<?xml version="1.0" encoding="utf-8"?>

<!--
   The XML configuration file is validated against schema file IoC.Configuration.Schema.7579ADB2-0FBD-4210-A8CA-EE4B4646DB3F.xsd, 
   which can be found in folder IoC.Configuration.Content in output directory. 
   The schema file can also be downloaded from 
   http://oroptimizer.com/ioc.configuration/V2/IoC.Configuration.Schema.7579ADB2-0FBD-4210-A8CA-EE4B4646DB3F.xsd or in source code 
   project in Github.com.
   
   To use Visual Studio code completion based on schema contents, right click Properties on this file in Visual Studio, and in Schemas 
   field pick the schema IoC.Configuration.Schema.7579ADB2-0FBD-4210-A8CA-EE4B4646DB3F.xsd.

   Before running the tests make sure to execute IoC.Configuration\Tests\IoC.Configuration.Tests\PostBuildCommands.bat to copy the dlls into 
   folders specified in this configuration file.
   Also, modify the batch file to copy the Autofac and Ninject assemblies from Nuget packages folder on machine, where the test is run.
-->

<iocConfiguration
        xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance'
        xsi:noNamespaceSchemaLocation="http://oroptimizer.com/IoC.Configuration/V2/IoC.Configuration.Schema.7579ADB2-0FBD-4210-A8CA-EE4B4646DB3F.xsd">

    <!--The application should have write permissions to path specified in appDataDir. 
      This is where dynamically generated DLLs are saved.-->
    <!--NOTE: path should be an absolute path, or should be converted to absolute path by some implementation of 
	IoC.Configuration.AttributeValueTransformer.IAttributeValueTransformer. In this example the paths are converted by 
	IoC.Configuration.Tests.FileFolderPathAttributeValueTransformer.-->
    <appDataDir
            path="TestFiles\AutogeneratedDlls\DynamicFiles_ProxyServiceTests"/>

    <plugins
            pluginsDirPath="TestFiles\PluginDlls">

        <!--        
            Plugin assemblies will be in a folder with similar name under pluginsDirPath folder.
            The plugin folders will be included in assembly resolution mechanism.        
            -->

        <!--A folder K:\...\IoC.Configuration\Tests\IoC.Configuration.Tests\bin\TestFiles\PluginDlls\Plugin1 should exist.  -->
        <plugin name="Plugin1"/>
        <plugin name="Plugin2" enabled="true"/>
        <plugin name="Plugin3" enabled="false"/>
    </plugins>

    <additionalAssemblyProbingPaths>
        <probingPath
                path="TestFiles\ThirdPartyLibs"/>
        <probingPath
                path="TestFiles\ContainerImplementations\Autofac"/>
        <probingPath
                path="TestFiles\ContainerImplementations\Ninject"/>
        <probingPath
                path="TestFiles\DynamicallyLoadedDlls"/>
    </additionalAssemblyProbingPaths>

    <assemblies>
        <!--Assemblies should be in one of the following locations:
            1) Executable's folder
            2) In folder specified in additionalAssemblyProbingPaths element.
            3) In one of the plugin folders specified in plugins element (only for assemblies with plugin attribute) -->

        <!--
        Use "overrideDirectory" attribute, to make the assembly path explicit, rather then searching for
        an assembly in predefined folders, which also include probing paths specified in additionalAssemblyProbingPaths element.
        -->
        <assembly name="IoC.Configuration.Autofac" alias="autofac_ext"/>
        <assembly name="IoC.Configuration.Ninject" alias="ninject_ext"/>

        <assembly name="TestProjects.Modules" alias="modules"/>

        <assembly name="TestProjects.DynamicallyLoadedAssembly1"
                  alias="dynamic1"/>

        <assembly name="TestProjects.DynamicallyLoadedAssembly2"
                  alias="dynamic2"/>

        <assembly name="TestProjects.TestPluginAssembly1"
                  alias="pluginassm1" plugin="Plugin1"/>

        <assembly name="TestProjects.TestPluginAssembly2"
                  alias="pluginassm2" plugin="Plugin2"/>

        <assembly name="TestProjects.TestPluginAssembly3"
                  alias="pluginassm3" plugin="Plugin3"/>

        <assembly name="TestProjects.ModulesForPlugin1"
                  alias="modules_plugin1" plugin="Plugin1"/>

        <assembly name="TestProjects.SharedServices" alias="shared_services"/>

        <assembly name="IoC.Configuration.Tests" alias="tests"/>
    </assemblies>

    <typeDefinitions>
        <typeDefinition alias="IAppData" type="IoC.Configuration.Tests.ProxyService.Services.IAppData"/>
        <typeDefinition alias="AppData" type="IoC.Configuration.Tests.ProxyService.Services.AppData"/>
        <typeDefinition alias="Guid" type="System.Guid"/>
        <typeDefinition alias="ListOfInt" type="System.Collections.Generic.List[System.Int32]"/>
    </typeDefinitions>

    <parameterSerializers>
        <serializers></serializers>
    </parameterSerializers>

    <!--The value of type attribute should be a type that implements 
      IoC.Configuration.DiContainer.IDiManager-->
    <diManagers activeDiManagerName="Autofac">
        <!-- TODO:-->
        <diManager name="Ninject" type="IoC.Configuration.Ninject.NinjectDiManager"
                   assembly="ninject_ext">
            <!--
                  Use parameters element to specify constructor parameters,
                  if the type specified in 'type' attribute has non-default constructor.
                  -->
            <!--<parameters>
                  </parameters>-->
        </diManager>

        <diManager name="Autofac" type="IoC.Configuration.Autofac.AutofacDiManager"
                   assembly="autofac_ext">
        </diManager>
    </diManagers>

    <!--
      If settingsRequestor element is used, the type in type attribute should 
      specify a type that implements IoC.Configuration.ISettingsRequestor. 
      The implementation specifies a collection of required settings that should be present
      in settings element.
      Note, the type specified in type attribute is fully integrated into a dependency 
      injection framework. In other words, constructor parameters will be injected using 
      bindings specified in dependencyInjection element.
      -->

    <settings>
        <constructedValue name="DefaultAppData" typeRef="AppData">
            <injectedProperties>
                <object name="ApplicationId" typeRef="Guid" value="09E7ABD4-1BA1-4683-BEF5-EFA8266D7308"/>
                <string name="Name" value="Default Application"/>
            </injectedProperties>
        </constructedValue>

    </settings>

    <dependencyInjection>
        <modules>
            <!--<module type="IoC.Configuration.Tests.AutoService.AutoServiceTestsModule" />-->
        </modules>
        <services>

            <!--IoC.Configuration.Tests.ProxyService.Services.IAppManager will be resolved 
            by resolving IoC.Configuration.Tests.ProxyService.Services.IAppManager_Extension.-->
            <proxyService type="IoC.Configuration.Tests.ProxyService.Services.IAppManager">
                <serviceToProxy type="IoC.Configuration.Tests.ProxyService.Services.IAppManager_Extension"/>
            </proxyService>

            <!--IoC.Configuration.Tests.ProxyService.Services.IAppManager2 will also be resolved to
                IoC.Configuration.Tests.ProxyService.Services.IAppManager_Extension.-->
            <proxyService type="IoC.Configuration.Tests.ProxyService.Services.IAppManager2">
                <serviceToProxy type="IoC.Configuration.Tests.ProxyService.Services.IAppManager_Extension"/>
            </proxyService>

            <!--
                AppManagerUser has a constructor with parameter of type IAppManager. 
                Since we have a proxyService element that resolves IAppManager to IAppManager_Extension,
                the object injected into constructor will be resolved by resolving the service IAppManager_Extension. 
                IAppManager_Extension is auto-implemented in autoGeneratedServices element, however, it 
                can have regular implementation in code as well.
                -->
            <selfBoundService type="IoC.Configuration.Tests.ProxyService.Services.AppManagerUser" scope="singleton"/>

            <!--
                AppManagerUser2 has a constructor with parameter of type  IAppManager2. 
                Since we have a proxyService element that resolves IAppManager2 to IAppManager_Extension,
                the object injected into will be resolved by resolving the service IAppManager_Extension.
                -->
            <selfBoundService type="IoC.Configuration.Tests.ProxyService.Services.AppManager2User" scope="singleton"/>

            <service type="IoC.Configuration.Tests.ProxyService.Services.IInterface1_Extension">
                <implementation type="IoC.Configuration.Tests.ProxyService.Services.Interface1_Extension_Impl1"
                                scope="singleton"/>
            </service>

            <!--IoC.Configuration.Tests.ProxyService.Services.IInterface1 will be resolved by
              resolving IoC.Configuration.Tests.ProxyService.Services.IInterface1_Extension.-->
            <proxyService type="IoC.Configuration.Tests.ProxyService.Services.IInterface1">
                <serviceToProxy type="IoC.Configuration.Tests.ProxyService.Services.IInterface1_Extension"/>
            </proxyService>

            <!--
                Interface1User has a constructor with parameter of type IInterface1. 
                Since we have a proxyService element that resolves IInterface1 to IInterface1_Extension,
                the object injected into constructor will be resolved by resolving the service IInterface1_Extension.
                -->
            <selfBoundService type="IoC.Configuration.Tests.ProxyService.Services.Interface1User" scope="singleton"/>

            <!--System.Collections.Generic.List<System.Int32> will be bound to a list of three integers: 19, 2, 17-->
            <service typeRef="ListOfInt">
                <valueImplementation scope="singleton">
                    <collection>
                        <int32 value="19"/>
                        <int32 value="2"/>
                        <int32 value="17"/>
                    </collection>
                </valueImplementation>
            </service>

            <!--Resolving System.Collections.Generic.IEnumerable<System.Int32> will return the same value as resolving 
                  System.Collections.Generic.List<System.Int32>-->
            <proxyService type="System.Collections.Generic.IEnumerable[System.Int32]">
                <serviceToProxy typeRef="ListOfInt"/>
            </proxyService>

            <!--Resolving System.Collections.Generic.IReadOnlyList<System.Int32> will return the same value as resolving 
                  System.Collections.Generic.List<System.Int32>-->
            <proxyService type="System.Collections.Generic.IReadOnlyList[System.Int32]">
                <serviceToProxy typeRef="ListOfInt"/>
            </proxyService>

            <!--Resolving System.Collections.Generic.IList<System.Int32> will return the same value as resolving 
                  System.Collections.Generic.List<System.Int32>-->
            <proxyService type="System.Collections.Generic.IList[System.Int32]">
                <serviceToProxy typeRef="ListOfInt"/>
            </proxyService>

            <!--START-Test binding an interface to the ame instance to which a self-bound class is bound-->
            <selfBoundService type="SharedServices.Implementations.Interface13_Impl1" scope="singleton" />

            <!--NOTE: Using proxyService allows us to bind 
            SharedServices.Interfaces.IInterface13 to the same instance of SharedServices.Implementations.Interface13_Impl1 to which
            SharedServices.Implementations.Interface13_Impl1 was bound using selfBoundService element.
            
            If we used "implementation" element under service and specified a type SharedServices.Implementations.Interface13_Impl1
            instead of using "proxyService", then SharedServices.Interfaces.IInterface13 would have been 
            bound to a different instance of SharedServices.Implementations.Interface13_Impl1. In other words resolving
            SharedServices.Implementations.Interface13_Impl1 and SharedServices.Interfaces.IInterface13 would have resulted in 
            different instances of SharedServices.Implementations.Interface13_Impl1.
            Using "proxyService" element might be useful when we have module(s) that scan assemblies and self-binds 
            non-abstract classes. In this cases we can use "proxyService" element if we want the interface
            specified in "proxyService" element to resolve to exactly the same value to which the self bound class is bound.
            -->
            <proxyService type="SharedServices.Interfaces.IInterface13">
                <serviceToProxy type="SharedServices.Implementations.Interface13_Impl1"/>
            </proxyService>

            <service type="SharedServices.Interfaces.IInterface14">
                <implementation type="SharedServices.Implementations.Interface14_Impl1" scope="singleton" />
            </service>

            <!--END-Test binding an interface to the ame instance to which a self-bound class is bound-->
        </services>

        <autoGeneratedServices>
            <!--The scope for autoService implementations is always singleton -->
            <!--IAppManager_Extension extends IAppManager, so can implement properties and method in both 
              IAppManager and IAppManager_Extension
            -->
            <autoService interface="IoC.Configuration.Tests.ProxyService.Services.IAppManager_Extension">
                <!--  IAppData IAppManager.GetApp(System.Guid applicationId):-->
                <autoMethod name="GetApp"
                            returnTypeRef="IAppData"
                            reuseValue="true">
                    <methodSignature>
                        <object typeRef="Guid"/>
                    </methodSignature>

                    <if parameter1="3907D19A-E53C-4471-B1B1-A3E0C36482B6">
                        <constructedValue typeRef="AppData">
                            <injectedProperties>
                                <object name="ApplicationId" typeRef="Guid"
                                        value="3907D19A-E53C-4471-B1B1-A3E0C36482B6"/>
                                <string name="Name" value="App1"/>
                            </injectedProperties>
                        </constructedValue>
                    </if>

                    <if parameter1="09E7ABD4-1BA1-4683-BEF5-EFA8266D7308">
                        <constructedValue typeRef="AppData">
                            <injectedProperties>
                                <object name="ApplicationId" typeRef="Guid"
                                        value="09E7ABD4-1BA1-4683-BEF5-EFA8266D7308"/>
                                <string name="Name" value="App2"/>
                            </injectedProperties>
                        </constructedValue>
                    </if>

                    <default>
                        <settingValue settingName="DefaultAppData"/>
                    </default>
                </autoMethod>

                <!---bool IAppManager2.IsPublicApp(Guid applicationId):-->
                <autoMethod name="IsPublicApp" returnType="System.Boolean">
                    <methodSignature>
                        <object paramName="applicationId" typeRef="Guid"/>
                    </methodSignature>

                    <if parameter1="09E7ABD4-1BA1-4683-BEF5-EFA8266D7308">
                        <boolean value="true"/>
                    </if>

                    <default>
                        <boolean value="false"/>
                    </default>
                </autoMethod>

                <!-- IAppData IAppManager_Extension.DefaultApp { get; }-->
                <autoProperty name="DefaultApp" returnTypeRef="IAppData">
                    <settingValue settingName="DefaultAppData"/>
                </autoProperty>
            </autoService>
        </autoGeneratedServices>
    </dependencyInjection>

    <startupActions>

    </startupActions>

    <pluginsSetup>
        <pluginSetup plugin="Plugin1">
            <!--The type in pluginImplementation should be non-abstract class 
                that implements IoC.Configuration.IPlugin and which has a public constructor-->
            <pluginImplementation type="TestPluginAssembly1.Implementations.Plugin1_Simple">
            </pluginImplementation>

            <settings>
                <int32 name="Int32Setting1" value="10"/>
                <string name="StringSetting1" value="Some text"/>
            </settings>

            <dependencyInjection>
                <modules>
                </modules>

                <services>
                    <service type="TestPluginAssembly1.Interfaces.IDemoProxyService_Extension">
                        <implementation type="TestPluginAssembly1.Implementations.DemoProxyService_Extension_Impl"
                                        scope="singleton"/>
                    </service>

                    <!--TestPluginAssembly1.Interfaces.IDemoProxyServicewill be resolved by
                        resolving TestPluginAssembly1.Interfaces.IDemoProxyService_Extension.-->
                    <proxyService type="TestPluginAssembly1.Interfaces.IDemoProxyService">
                        <serviceToProxy type="TestPluginAssembly1.Interfaces.IDemoProxyService_Extension"/>
                    </proxyService>

                    <!--
                    DemoProxyServiceUser has a constructor with parameter of type IDemoProxyService. 
                    Since we have a proxyService element that resolves IDemoProxyService to IDemoProxyService_Extension,
                    the object injected into constructor will be resolved by resolving the service IDemoProxyService_Extension.
                    -->
                    <selfBoundService type="TestPluginAssembly1.Implementations.DemoProxyServiceUser"
                                      scope="singleton"/>
                </services>

                <autoGeneratedServices>

                </autoGeneratedServices>
            </dependencyInjection>
        </pluginSetup>

        <pluginSetup plugin="Plugin2">
            <pluginImplementation type="TestPluginAssembly2.Implementations.Plugin2" assembly="pluginassm2">
                <parameters>
                    <boolean name="param1" value="true"/>
                    <double name="param2" value="25.3"/>
                    <string name="param3" value="String value"/>
                </parameters>
            </pluginImplementation>
            <settings>
            </settings>
            <dependencyInjection>
                <modules>
                </modules>
                <services>
                </services>
                <autoGeneratedServices>
                </autoGeneratedServices>
            </dependencyInjection>
        </pluginSetup>

        <pluginSetup plugin="Plugin3">
            <pluginImplementation type="TestPluginAssembly3.Implementations.Plugin3" assembly="pluginassm3">

            </pluginImplementation>
            <settings>
            </settings>
            <dependencyInjection>
                <modules>
                </modules>
                <services>
                </services>
                <autoGeneratedServices>
                </autoGeneratedServices>
            </dependencyInjection>
        </pluginSetup>
    </pluginsSetup>
</iocConfiguration>