<?xml version="1.0"?>
<doc>
    <assembly>
        <name>IoC.Configuration</name>
    </assembly>
    <members>
        <member name="T:IoC.Configuration.ConfigurationFileXmlDocumentLoadedEventArgs">
            <summary>
                Event arguments for the configuration XmlDocument.
            </summary>
        </member>
        <member name="M:IoC.Configuration.ConfigurationFileXmlDocumentLoadedEventArgs.#ctor(System.Xml.XmlDocument)">
            <summary>
                A constructor.
            </summary>
            <param name="xmlDocument"></param>
        </member>
        <member name="P:IoC.Configuration.ConfigurationFileXmlDocumentLoadedEventArgs.XmlDocument">
            <summary>
                Event arguments for the configuration XmlDocument.
                Note, the XmlDocument is not yet validated against schema. Therefore, if the XmlDocument is modified,
                it should be modified in such a way, that it still confirms to schema.
            </summary>
        </member>
        <member name="M:IoC.Configuration.ConfigurationFile.Helpers.ConvertTo``1(IoC.Configuration.ConfigurationFile.IConfigurationFileElement)">
            <summary>
                Converts <paramref name="configurationFileElement" /> to type <typeparamref name="T" />. Throws an exception if the
                conversion fails.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="configurationFileElement"></param>
            <returns>Converted value.</returns>
            <exception cref="T:IoC.Configuration.ConfigurationFile.ConfigurationParseException">Throws this exception.</exception>
        </member>
        <member name="M:IoC.Configuration.ConfigurationFile.Helpers.GetAssemblySettingByAssemblyAlias(IoC.Configuration.ConfigurationFile.IConfigurationFileElement,System.String)">
            <summary>
            </summary>
            <param name="requestorFileElement"></param>
            <param name="assemblyAlias"></param>
            <returns></returns>
            <exception cref="T:IoC.Configuration.ConfigurationFile.ConfigurationParseException">
                Throws this exception if the assembly with specified alias
                does not exitst in configuration file.
            </exception>
        </member>
        <member name="M:IoC.Configuration.ConfigurationFile.Helpers.GetAttributeValue``1(IoC.Configuration.ConfigurationFile.IConfigurationFileElement,System.String)">
            <summary>
            </summary>
            <typeparam name="T"></typeparam>
            <param name="configurationFileElement"></param>
            <param name="attributeName"></param>
            <returns></returns>
            <exception cref="T:IoC.Configuration.ConfigurationFile.ConfigurationParseException">
                Throws this exception if the attribute value cannot be converted to type
                of 'T'.
            </exception>
        </member>
        <member name="M:IoC.Configuration.ConfigurationFile.Helpers.GetEnabledAttributeValue(IoC.Configuration.ConfigurationFile.IConfigurationFileElement)">
            <summary>
            </summary>
            <param name="configurationFileElement"></param>
            <exception cref="T:IoC.Configuration.ConfigurationFile.ConfigurationParseException">
                Throws this exception if the attribute value cannot be conveted to a
                boolean value.
            </exception>
        </member>
        <member name="M:IoC.Configuration.ConfigurationFile.Helpers.GetNameAttributeValue(IoC.Configuration.ConfigurationFile.IConfigurationFileElement)">
            <summary>
            </summary>
            <param name="configurationFileElement"></param>
            <exception cref="T:IoC.Configuration.ConfigurationFile.ConfigurationParseException">Throws this exception if the attribute value is null or empty string.</exception>
        </member>
        <member name="M:IoC.Configuration.ConfigurationFile.Helpers.GetTypeInAssembly(IoC.Configuration.IAssemblyLocator,IoC.Configuration.ConfigurationFile.IConfigurationFileElement,IoC.Configuration.ConfigurationFile.IAssembly,System.String)">
            <summary>
            </summary>
            <param name="assemblyLocator"></param>
            <param name="requestorFileElement"></param>
            <param name="assemblyElement"></param>
            <param name="typeFullName"></param>
            <returns></returns>
            <exception cref="T:IoC.Configuration.ConfigurationFile.ConfigurationParseException">Throws this exception if the type is not in an assembly.</exception>
        </member>
        <member name="P:IoC.Configuration.ConfigurationFile.IAssembly.AbsolutePath">
            <summary>
                Absolute full path of assembly file.
            </summary>
        </member>
        <member name="M:IoC.Configuration.ConfigurationFile.IConfigurationFileElement.AddChild(IoC.Configuration.ConfigurationFile.IConfigurationFileElement)">
            <summary>
            </summary>
            <param name="child"></param>
            <exception cref="T:IoC.Configuration.ConfigurationFile.ConfigurationParseException"></exception>
        </member>
        <member name="M:IoC.Configuration.ConfigurationFile.IConfigurationFileElement.Initialize">
            <summary>
            </summary>
            <exception cref="T:IoC.Configuration.ConfigurationFile.ConfigurationParseException"></exception>
        </member>
        <member name="P:IoC.Configuration.ConfigurationFile.IConfigurationFileElement.OwningPluginElement">
            <summary>
                If not null, specifies the plugin to which the element is applicable. Otherwise, the element does not belong to any
                plugin.
            </summary>
        </member>
        <member name="M:IoC.Configuration.ConfigurationFile.IConfigurationFileElement.ValidateAfterChildrenAdded">
            <summary>
            </summary>
            <exception cref="T:IoC.Configuration.ConfigurationFile.ConfigurationParseException"></exception>
        </member>
        <member name="M:IoC.Configuration.ConfigurationFile.IConfigurationFileElementFactory.CreateConfigurationFileElement(System.Xml.XmlElement,IoC.Configuration.ConfigurationFile.IConfigurationFileElement)">
            <summary>
            </summary>
            <param name="xmlElement"></param>
            <param name="parentConfigurationFileElement"></param>
            <exception cref="T:System.Exception">Throws an exception if can't create an element.</exception>
            <returns></returns>
            <exception cref="T:IoC.Configuration.ConfigurationFile.ConfigurationParseException"></exception>
        </member>
        <member name="P:IoC.Configuration.ConfigurationFile.IDiManagersElement.ActiveDiManagerElement">
            <summary>
                The value is not null, if the configuration file is successfully loaded.
            </summary>
        </member>
        <member name="P:IoC.Configuration.ConfigurationFile.IModuleElement.DiModule">
            <summary>
                Is null if the module is disabled.
                Has non null value otherwise.
            </summary>
        </member>
        <member name="P:IoC.Configuration.ConfigurationFile.IParameterElement.DeserializedValue">
            <summary>
                The value deserialized from ValueAsString to type in property <see cref="P:IoC.Configuration.INamedValue.ValueType" />
            </summary>
        </member>
        <member name="P:IoC.Configuration.ConfigurationFile.IParameterSerializer.Serializer">
            <summary>
                Can be null only if Enabled is false.
            </summary>
        </member>
        <member name="T:IoC.Configuration.ConfigurationFile.IProhibitedServiceTypesInServicesElementChecker">
            <summary>
                Checks if the given type can be used as a service type under 'services' element in configuration file.
            </summary>
        </member>
        <member name="M:IoC.Configuration.ConfigurationFile.IProhibitedServiceTypesInServicesElementChecker.IsServiceTypeAllowed(System.Type)">
            <summary>
                Checks if <paramref name="serviceType" /> can be used as a service type under
                'services' element in configuration file.
            </summary>
            <param name="serviceType"></param>
            <returns>
                Returns true if <paramref name="serviceType" /> can be used as a service type under
                'services' element in configuration file.
                Returns false otherwise.
            </returns>
        </member>
        <member name="P:IoC.Configuration.ConfigurationFile.ITypeFactory.ImplementedMethodInfo">
            <summary>
                Null only of element is disabled
            </summary>
        </member>
        <member name="P:IoC.Configuration.ConfigurationFile.ITypeFactoryReturnedType.ReturnedType">
            <summary>
                Null only of element is disabled
            </summary>
        </member>
        <member name="M:IoC.Configuration.ConfigurationFile.Services.ThrowOnProhibitedServiceType(IoC.Configuration.ConfigurationFile.IServiceElement,System.String)">
            <summary>
            </summary>
            <param name="serviceElement"></param>
            <param name="serviceImplementatipnLocation"></param>
            <exception cref="T:IoC.Configuration.ConfigurationFile.ConfigurationParseException">Always throws this exception.</exception>
        </member>
        <member name="T:IoC.Configuration.DiContainerBuilder.CodeBased.CodeBasedConfiguration">
            <summary>
            A class that stores data for building dependency injection container using code based configuration.
            </summary>
            <seealso cref="T:IoC.Configuration.DiContainerBuilder.DiContainerBuilderConfiguration" />
        </member>
        <member name="M:IoC.Configuration.DiContainerBuilder.CodeBased.CodeBasedConfiguration.#ctor(IoC.Configuration.DiContainer.IDiManager,System.String,System.String[])">
            <summary>
            Initializes a new instance of the <see cref="T:IoC.Configuration.DiContainerBuilder.CodeBased.CodeBasedConfiguration"/> class.
            </summary>
            <param name="diManager">The DI manager.</param>
            <param name="entryAssemblyFolder">
                The location where the executable is.
                For non test projects <see cref="P:OROptimizer.IGlobalsCore.EntryAssemblyFolder" /> can be used as a value for this parameter.
                However, for tests projects <see cref="P:OROptimizer.IGlobalsCore.EntryAssemblyFolder" /> might be
                be the folder where the test execution library is, so a different value might need to be passed.
            </param>
            <param name="assemblyProbingPaths">The assembly probing paths.</param>
        </member>
        <member name="M:IoC.Configuration.DiContainerBuilder.CodeBased.CodeBasedConfiguration.#ctor(System.String,System.String,OROptimizer.ParameterInfo[],System.String,System.String[])">
            <summary>
            </summary>
            <param name="diManagerClassFullName"></param>
            <param name="diManagerClassAssemblyFilePath"></param>
            <param name="diManagerConstructorParameters"></param>
            <param name="entryAssemblyFolder">
                The location where the executable is.
                For non test projects <see cref="P:OROptimizer.IGlobalsCore.EntryAssemblyFolder" /> can be used as a value for this parameter.
                However, for tests projects <see cref="P:OROptimizer.IGlobalsCore.EntryAssemblyFolder" /> might be
                be the folder where the test execution library is, so a different value might need to be passed.
            </param>
            <param name="assemblyProbingPaths"></param>
        </member>
        <member name="M:IoC.Configuration.DiContainerBuilder.CodeBased.CodeBasedConfiguration.Dispose">
            <summary>
            Releases unmanaged and - optionally - managed resources.
            </summary>
        </member>
        <member name="M:IoC.Configuration.DiContainerBuilder.CodeBased.CodeBasedConfiguration.DefaultModule.AddServiceRegistrations">
            <summary>
                Use OnlyIfNotRegistered with all binding configurations, to use custom binding that the user might have specified
                in configuration
                file or in modules.
            </summary>
        </member>
        <member name="M:IoC.Configuration.DiContainerBuilder.CodeBased.CodeBasedConfiguratorAbstr.#ctor(IoC.Configuration.DiContainerBuilder.CodeBased.CodeBasedConfiguration)">
            <summary>
            Initializes a new instance of the <see cref="T:IoC.Configuration.DiContainerBuilder.CodeBased.CodeBasedConfiguratorAbstr"/> class.
            </summary>
            <param name="codeBasedConfiguration">The code based configuration.</param>
        </member>
        <member name="M:IoC.Configuration.DiContainerBuilder.CodeBased.CodeBasedContainerStarter.#ctor(IoC.Configuration.DiContainerBuilder.CodeBased.CodeBasedConfiguration)">
            <summary>
            Initializes a new instance of the <see cref="T:IoC.Configuration.DiContainerBuilder.CodeBased.CodeBasedContainerStarter"/> class.
            </summary>
            <param name="codeBasedConfiguration">The code based configuration.</param>
        </member>
        <member name="M:IoC.Configuration.DiContainerBuilder.CodeBased.CodeBasedContainerStarter.Start">
            <summary>
            Loads the DI container.
            </summary>
            <returns>Returns an instance of <see cref="T:IoC.Configuration.DiContainerBuilder.IContainerInfo"/>.</returns>
        </member>
        <member name="M:IoC.Configuration.DiContainerBuilder.CodeBased.CodeBasedDiContainerConfigurator.#ctor(IoC.Configuration.DiContainerBuilder.CodeBased.CodeBasedConfiguration)">
            <summary>
            Initializes a new instance of the <see cref="T:IoC.Configuration.DiContainerBuilder.CodeBased.CodeBasedDiContainerConfigurator"/> class.
            </summary>
            <param name="codeBasedConfiguration">The code based configuration.</param>
        </member>
        <member name="M:IoC.Configuration.DiContainerBuilder.CodeBased.CodeBasedDiContainerConfigurator.WithDiContainer(IoC.Configuration.DiContainer.IDiContainer)">
            <summary>
            Creates an instance of <see cref="T:IoC.Configuration.DiContainerBuilder.CodeBased.ICodeBasedDiModulesConfigurator"/> using a preset instance of <see cref="T:IoC.Configuration.DiContainer.IDiContainer"/>.
            Use the method <see cref="M:IoC.Configuration.DiContainerBuilder.CodeBased.CodeBasedDiContainerConfigurator.WithDiContainer(IoC.Configuration.DiContainer.IDiContainer)"/> if possible.
            </summary>
            <param name="diContainer">An instance of <see cref="T:IoC.Configuration.DiContainer.IDiContainer"/>.</param>
            <returns>Returns an instance of <see cref="T:IoC.Configuration.DiContainerBuilder.CodeBased.ICodeBasedDiModulesConfigurator"/></returns>
        </member>
        <member name="M:IoC.Configuration.DiContainerBuilder.CodeBased.CodeBasedDiContainerConfigurator.WithoutPresetDiContainer">
            <summary>
            This is the preferred method. An instance of <see cref="T:IoC.Configuration.DiContainer.IDiContainer"/> will be initialized using the
            method <see cref="M:IoC.Configuration.DiContainer.IDiManager.CreateDiContainer"/>() in <see cref="T:IoC.Configuration.DiContainer.IDiManager"/>.
            </summary>
            <returns>Returns an instance of <see cref="T:IoC.Configuration.DiContainerBuilder.CodeBased.ICodeBasedDiModulesConfigurator"/></returns>
        </member>
        <member name="M:IoC.Configuration.DiContainerBuilder.CodeBased.CodeBasedDiContainerConfigurator.RegisterModules">
            <summary>
            Registers the modules.
            </summary>
            <returns></returns>
        </member>
        <member name="M:IoC.Configuration.DiContainerBuilder.CodeBased.CodeBasedDiModulesConfigurator.#ctor(IoC.Configuration.DiContainerBuilder.CodeBased.CodeBasedConfiguration)">
            <summary>
            Initializes a new instance of the <see cref="T:IoC.Configuration.DiContainerBuilder.CodeBased.CodeBasedDiModulesConfigurator"/> class.
            </summary>
            <param name="codeBasedConfiguration">The code based configuration.</param>
        </member>
        <member name="M:IoC.Configuration.DiContainerBuilder.CodeBased.CodeBasedDiModulesConfigurator.AddDiModules(IoC.Configuration.DiContainer.IDiModule[])">
            <summary>
            Adds the additional <see cref="T:IoC.Configuration.DiContainer.IDiModule"/> modules to be loaded into a container.
            </summary>
            <param name="diModules">The <see cref="T:IoC.Configuration.DiContainer.IDiModule"/> modules to be loaded into a container.</param>
            <returns>Returns an instance of <see cref="T:IoC.Configuration.DiContainerBuilder.CodeBased.ICodeBasedDiModulesConfigurator"/></returns>
        </member>
        <member name="M:IoC.Configuration.DiContainerBuilder.CodeBased.CodeBasedDiModulesConfigurator.AddNativeModule(System.String,System.String,OROptimizer.ParameterInfo[])">
            <summary>
             Add native module, such as Autofac or Ninject module to be loaded into a container.
            </summary>
            <param name="nativeModuleClassFullName">Full name of the native module class.</param>
            <param name="nativeModuleClassAssemblyFilePath">The native module class assembly file path.</param>
            <param name="nativeModuleConstructorParameters">The native module constructor parameters.</param>
            <returns>Returns an instance of <see cref="T:IoC.Configuration.DiContainerBuilder.CodeBased.ICodeBasedDiModulesConfigurator"/></returns>
        </member>
        <member name="M:IoC.Configuration.DiContainerBuilder.CodeBased.CodeBasedDiModulesConfigurator.AddNativeModules(System.Object[])">
            <summary>
            Add native modules, such as Autofac or Ninject modules to be loaded into a container.
            </summary>
            <param name="nativeModules">The native modules, such as Autofac or Ninject modules to be loaded into a container.</param>
            <returns>Returns an instance of <see cref="T:IoC.Configuration.DiContainerBuilder.CodeBased.ICodeBasedDiModulesConfigurator"/></returns>
        </member>
        <member name="M:IoC.Configuration.DiContainerBuilder.CodeBased.CodeBasedDiModulesConfigurator.RegisterModules">
            <summary>
            Registers the modules.
            </summary>
            <returns></returns>
        </member>
        <member name="M:IoC.Configuration.DiContainerBuilder.CodeBased.ICodeBasedContainerStarter.Start">
            <summary>
            Loads the DI container.
            </summary>
            <returns>Returns an instance of <see cref="T:IoC.Configuration.DiContainerBuilder.IContainerInfo"/>.</returns>
        </member>
        <member name="M:IoC.Configuration.DiContainerBuilder.CodeBased.ICodeBasedDiContainerConfigurator.WithDiContainer(IoC.Configuration.DiContainer.IDiContainer)">
            <summary>
            Creates an instance of <see cref="T:IoC.Configuration.DiContainerBuilder.CodeBased.ICodeBasedDiModulesConfigurator"/> using a preset instance of <see cref="T:IoC.Configuration.DiContainer.IDiContainer"/>.
            Use the method <see cref="M:IoC.Configuration.DiContainerBuilder.CodeBased.ICodeBasedDiContainerConfigurator.WithDiContainer(IoC.Configuration.DiContainer.IDiContainer)"/> if possible.
            </summary>
            <param name="diContainer">An instance of <see cref="T:IoC.Configuration.DiContainer.IDiContainer"/>.</param>
            <returns>Returns an instance of <see cref="T:IoC.Configuration.DiContainerBuilder.CodeBased.ICodeBasedDiModulesConfigurator"/></returns>
        </member>
        <member name="M:IoC.Configuration.DiContainerBuilder.CodeBased.ICodeBasedDiContainerConfigurator.WithoutPresetDiContainer">
            <summary>
                The container will be automatically created. This is the preferred way to build a container.
                Use <see cref="M:IoC.Configuration.DiContainerBuilder.CodeBased.ICodeBasedDiContainerConfigurator.WithDiContainer(IoC.Configuration.DiContainer.IDiContainer)" /> only if the application already has a container, and we need to use it.
            </summary>
            <returns>Returns an instance of <see cref="T:IoC.Configuration.DiContainerBuilder.CodeBased.ICodeBasedDiModulesConfigurator"/></returns>
        </member>
        <member name="M:IoC.Configuration.DiContainerBuilder.CodeBased.ICodeBasedDiModulesConfigurator.AddDiModules(IoC.Configuration.DiContainer.IDiModule[])">
            <summary>
            Adds the additional <see cref="T:IoC.Configuration.DiContainer.IDiModule"/> modules to be loaded into a container.
            </summary>
            <param name="diModules">The <see cref="T:IoC.Configuration.DiContainer.IDiModule"/> modules to be loaded into a container.</param>
            <returns>Returns an instance of <see cref="T:IoC.Configuration.DiContainerBuilder.CodeBased.ICodeBasedDiModulesConfigurator"/></returns>
        </member>
        <member name="M:IoC.Configuration.DiContainerBuilder.CodeBased.ICodeBasedDiModulesConfigurator.AddNativeModule(System.String,System.String,OROptimizer.ParameterInfo[])">
            <summary>
             Add native module, such as Autofac or Ninject module to be loaded into a container.
            </summary>
            <param name="nativeModuleClassFullName">Full name of the native module class.</param>
            <param name="nativeModuleClassAssemblyFilePath">The native module class assembly file path.</param>
            <param name="nativeModuleConstructorParameters">The native module constructor parameters.</param>
            <returns>Returns an instance of <see cref="T:IoC.Configuration.DiContainerBuilder.CodeBased.ICodeBasedDiModulesConfigurator"/></returns>
        </member>
        <member name="M:IoC.Configuration.DiContainerBuilder.CodeBased.ICodeBasedDiModulesConfigurator.AddNativeModules(System.Object[])">
            <summary>
            Add native modules, such as Autofac or Ninject modules to be loaded into a container.
            </summary>
            <param name="nativeModules">The native modules, such as Autofac or Ninject modules to be loaded into a container.</param>
            <returns>Returns an instance of <see cref="T:IoC.Configuration.DiContainerBuilder.CodeBased.ICodeBasedDiModulesConfigurator"/></returns>
        </member>
        <member name="M:IoC.Configuration.DiContainerBuilder.CodeBased.IRegisterModulesWithDiManagerForCodeBasedConfiguration.RegisterModules">
            <summary>
            Registers the modules.
            </summary>
            <returns></returns>
        </member>
        <member name="T:IoC.Configuration.DiContainerBuilder.ContainerInfo">
            <summary>
            Container data for the loaded DI
            </summary>
            <seealso cref="T:IoC.Configuration.DiContainerBuilder.IContainerInfo" />
        </member>
        <member name="P:IoC.Configuration.DiContainerBuilder.ContainerInfo.DiContainer">
            <summary>
            An instance of <see cref="T:IoC.Configuration.DiContainer.IDiContainer" /> for the loaded container.
            </summary>
            <value>
            The di container.
            </value>
        </member>
        <member name="M:IoC.Configuration.DiContainerBuilder.ContainerInfo.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
        </member>
        <member name="T:IoC.Configuration.DiContainerBuilder.DiContainerBuilder">
            <summary>
            A DI container builder.
            </summary>
        </member>
        <member name="M:IoC.Configuration.DiContainerBuilder.DiContainerBuilder.StartCodeBasedDi(IoC.Configuration.DiContainer.IDiManager,System.String,System.String[])">
            <summary>
            Creates an instance of <see cref="T:IoC.Configuration.DiContainerBuilder.CodeBased.ICodeBasedDiContainerConfigurator"/> for code based dependency injection configuration.
            </summary>
            <param name="diManager">An instance of <see cref="T:IoC.Configuration.DiContainer.IDiManager"/></param>
            <param name="entryAssemblyFolder">The entry assembly folder.</param>
            <param name="assemblyProbingPaths">The assembly probing paths.</param>
            <returns></returns>
            <exception cref="T:OROptimizer.Diagnostics.Log.LoggerWasNotInitializedException"></exception>
        </member>
        <member name="M:IoC.Configuration.DiContainerBuilder.DiContainerBuilder.StartCodeBasedDi(System.String,System.String,OROptimizer.ParameterInfo[],System.String,System.String[])">
            <summary>
            Creates an instance of <see cref="T:IoC.Configuration.DiContainerBuilder.CodeBased.ICodeBasedDiContainerConfigurator"/> for code based dependency injection configuration.
            </summary>
            <param name="diManagerClassFullName">Should be a full name of a class that implements <see cref="T:IoC.Configuration.DiContainer.IDiManager" />.</param>
            <param name="diManagerClassAssemblyFilePath">
                Full path of assembly, containing the class specified parameter
                <paramref name="diManagerClassFullName" />.
            </param>
            <param name="diManagerConstructorParameters">
                Collection of constructor parameter type/value combinations to be passed to a constructor in class specified
                in parameter <paramref name="diManagerClassFullName" />.
            </param>
            <param name="entryAssemblyFolder">The entry assembly folder.</param>
            <param name="assemblyProbingPaths">Additional assembly probing paths.</param>
        </member>
        <member name="M:IoC.Configuration.DiContainerBuilder.DiContainerBuilder.StartFileBasedDi(IoC.Configuration.IConfigurationFileContentsProvider,System.String,IoC.Configuration.ConfigurationFileXmlDocumentLoadedEventHandler)">
            <summary>
            Creates an instance of <see cref="T:IoC.Configuration.DiContainerBuilder.FileBased.IFileBasedDiContainerConfigurator"/> for file based dependency injection configuration.
            </summary>
            <param name="configurationFileContentsProvider">The configuration file contents provider.
            An example implementation of <see cref="T:IoC.Configuration.IConfigurationFileContentsProvider"/> implementation is <see cref="T:IoC.Configuration.FileBasedConfigurationFileContentsProvider"/>
            </param>
            <param name="entryAssemblyFolder">The entry assembly folder.</param>
            <param name="configurationFileXmlDocumentLoaded">The configuration file XML document loaded.</param>
            <returns></returns>
            <exception cref="T:OROptimizer.Diagnostics.Log.LoggerWasNotInitializedException"></exception>
        </member>
        <member name="T:IoC.Configuration.DiContainerBuilder.DiContainerBuilderConfiguration">
            <summary>
            A class that stores data for building dependency injection container.
            </summary>
            <seealso cref="T:System.IDisposable" />
        </member>
        <member name="M:IoC.Configuration.DiContainerBuilder.DiContainerBuilderConfiguration.#ctor(System.String)">
            <summary>
                A constructor.
            </summary>
            <param name="entryAssemblyFolder">
                The location where the executable is.
                For non test projects <see cref="P:OROptimizer.IGlobalsCore.EntryAssemblyFolder" /> can be used as a value for this parameter.
                However, for tests projects <see cref="P:OROptimizer.IGlobalsCore.EntryAssemblyFolder" /> might be
                be the folder where the test execution library is, so a different value might need to be passed.
            </param>
        </member>
        <member name="M:IoC.Configuration.DiContainerBuilder.DiContainerBuilderConfiguration.Init">
            <summary>
                Override this to do initialization. This method should be called after the object is constructed.
            </summary>
        </member>
        <member name="M:IoC.Configuration.DiContainerBuilder.DiContainerBuilderConfiguration.AddDiModules(IoC.Configuration.DiContainer.IDiModule[])">
            <summary>
            Adds DI modules of type <see cref="T:IoC.Configuration.DiContainer.IDiContainer"/> to container builder.
            </summary>
            <param name="diModules">The DI modules.</param>
        </member>
        <member name="M:IoC.Configuration.DiContainerBuilder.DiContainerBuilderConfiguration.AddNativeModules(System.Object[])">
            <summary>
            Adds native (such as Autofac or Ninject) modules to container builder.
            </summary>
            <param name="nativeModules">The native modules.</param>
        </member>
        <member name="P:IoC.Configuration.DiContainerBuilder.DiContainerBuilderConfiguration.DiContainer">
            <summary>
            Gets the DI container.
            </summary>
            <value>
            The DI container.
            </value>
        </member>
        <member name="P:IoC.Configuration.DiContainerBuilder.DiContainerBuilderConfiguration.DiManager">
            <summary>
            Gets or sets the DI manager.
            </summary>
            <value>
            The DI manager.
            </value>
        </member>
        <member name="P:IoC.Configuration.DiContainerBuilder.DiContainerBuilderConfiguration.NativeAndDiModules">
            <summary>
                List of native module objects (such as Autofac or Ninject modules), as well as <see cref="T:IoC.Configuration.DiContainer.IDiModule" /> objects
            </summary>
        </member>
        <member name="M:IoC.Configuration.DiContainerBuilder.DiContainerBuilderConfiguration.RegisterModulesWithDiManager">
            <summary>
            Registers the modules with DI manager.
            </summary>
        </member>
        <member name="M:IoC.Configuration.DiContainerBuilder.DiContainerBuilderConfiguration.StartContainer">
            <summary>
            Starts the container.
            </summary>
            <returns></returns>
        </member>
        <member name="M:IoC.Configuration.DiContainerBuilder.FileBased.FileBasedConfiguration.#ctor(IoC.Configuration.IConfigurationFileContentsProvider,System.String,IoC.Configuration.ConfigurationFileXmlDocumentLoadedEventHandler)">
            <summary>
            Initializes a new instance of the <see cref="T:IoC.Configuration.DiContainerBuilder.FileBased.FileBasedConfiguration"/> class.
            </summary>
            <param name="configurationFileContentsProvider">
            The configuration file contents provider. An example implementation of <see cref="T:IoC.Configuration.IConfigurationFileContentsProvider"/> implementation is <see cref="T:IoC.Configuration.FileBasedConfigurationFileContentsProvider"/>
            </param>
            <param name="entryAssemblyFolder">
                The location where the executable is.
                For non test projects <see cref="P:OROptimizer.IGlobalsCore.EntryAssemblyFolder" /> can be used as a value for this parameter.
                However, for tests projects <see cref="P:OROptimizer.IGlobalsCore.EntryAssemblyFolder" /> might be
                be the folder where the test execution library is, so a different value might need to be passed.
            </param>
            <param name="configurationFileXmlDocumentLoaded">
            The configuration file XML document loaded. 
            </param>
        </member>
        <member name="P:IoC.Configuration.DiContainerBuilder.FileBased.FileBasedConfiguration.Configuration">
            <summary>
            Gets the configuration loaded from the root iocConfiguration element. This property stores the entire configuration.
            </summary>
            <value>
            The configuration.
            </value>
        </member>
        <member name="M:IoC.Configuration.DiContainerBuilder.FileBased.FileBasedConfiguration.Dispose">
            <summary>
            Releases unmanaged and - optionally - managed resources.
            </summary>
        </member>
        <member name="M:IoC.Configuration.DiContainerBuilder.FileBased.FileBasedConfiguration.Init">
            <summary>
            This method should be called after the object is constructed.
            </summary>
        </member>
        <member name="M:IoC.Configuration.DiContainerBuilder.FileBased.FileBasedConfiguration.DefaultModule.AddServiceRegistrations">
            <summary>
                Use OnlyIfNotRegistered with all binding configurations, to use custom binding that the user might have specified
                in configuration
                file or in modules.
            </summary>
        </member>
        <member name="T:IoC.Configuration.DiContainerBuilder.FileBased.FileBasedConfiguration.ModuleInfo">
            <summary>
                This class stores details about native and non-native modules, and initializes the modules at a later time,
                when dynamic assembly is created.
            </summary>
        </member>
        <member name="M:IoC.Configuration.DiContainerBuilder.FileBased.FileBasedConfiguration.ModuleInfo.#ctor(IoC.Configuration.DiContainerBuilder.FileBased.FileBasedConfiguration,IoC.Configuration.DiContainer.BindingsForCode.IServiceRegistrationBuilder,System.Object)">
            <summary>
                Use this constructor for either native modules (e.g., Autofac or Ninject module), or modules of type
                <see cref="T:IoC.Configuration.DiContainer.IDiModule" />.
            </summary>
        </member>
        <member name="M:IoC.Configuration.DiContainerBuilder.FileBased.FileBasedConfiguration.ModuleInfo.#ctor(IoC.Configuration.DiContainerBuilder.FileBased.FileBasedConfiguration,System.String)">
            <summary>
                This constructor specifies a class full name for a native module.
            </summary>
            <param name="fileBasedConfiguration"></param>
            <param name="moduleClassFullName"></param>
        </member>
        <member name="M:IoC.Configuration.DiContainerBuilder.FileBased.FileBasedConfiguratorAbstr.#ctor(IoC.Configuration.DiContainerBuilder.FileBased.FileBasedConfiguration)">
            <summary>
            Initializes a new instance of the <see cref="T:IoC.Configuration.DiContainerBuilder.FileBased.FileBasedConfiguratorAbstr"/> class.
            </summary>
            <param name="fileBasedConfiguration">The file based configuration.</param>
        </member>
        <member name="M:IoC.Configuration.DiContainerBuilder.FileBased.FileBasedContainerStarter.#ctor(IoC.Configuration.DiContainerBuilder.FileBased.FileBasedConfiguration)">
            <summary>
            Initializes a new instance of the <see cref="T:IoC.Configuration.DiContainerBuilder.FileBased.FileBasedContainerStarter"/> class.
            </summary>
            <param name="fileBasedConfiguration">The file based configuration.</param>
        </member>
        <member name="M:IoC.Configuration.DiContainerBuilder.FileBased.FileBasedContainerStarter.Start">
            <summary>
             Loads the DI container from the configuration file.
            </summary>
            <returns>Returns an instance of <see cref="T:IoC.Configuration.DiContainerBuilder.IContainerInfo"/>.</returns>
        </member>
        <member name="M:IoC.Configuration.DiContainerBuilder.FileBased.FileBasedDiContainerConfigurator.#ctor(IoC.Configuration.DiContainerBuilder.FileBased.FileBasedConfiguration)">
            <summary>
            Initializes a new instance of the <see cref="T:IoC.Configuration.DiContainerBuilder.FileBased.FileBasedDiContainerConfigurator"/> class.
            </summary>
            <param name="fileBasedConfiguration">The file based configuration.</param>
        </member>
        <member name="M:IoC.Configuration.DiContainerBuilder.FileBased.FileBasedDiContainerConfigurator.RegisterModules">
            <summary>
            Registers the modules.
            </summary>
            <returns></returns>
        </member>
        <member name="M:IoC.Configuration.DiContainerBuilder.FileBased.FileBasedDiContainerConfigurator.WithDiContainer(IoC.Configuration.DiContainer.IDiContainer)">
            <summary>
            Will use <see cref="T:IoC.Configuration.DiContainer.IDiContainer"/> instance passed as a parameter when configuring the container.
            Use the method <see cref="M:IoC.Configuration.DiContainerBuilder.FileBased.FileBasedDiContainerConfigurator.WithDiContainer(IoC.Configuration.DiContainer.IDiContainer)"/> if possible.
            </summary>
            <param name="diContainer">An instance of <see cref="T:IoC.Configuration.DiContainer.IDiContainer"/>.</param>
            <returns>Returns an instance of <see cref="T:IoC.Configuration.DiContainerBuilder.FileBased.IFileBasedDiModulesConfigurator"/></returns>
        </member>
        <member name="M:IoC.Configuration.DiContainerBuilder.FileBased.FileBasedDiContainerConfigurator.WithoutPresetDiContainer">
            <summary>
            The container will be automatically created. This is the preferred way to build a container.
            Use <see cref="M:IoC.Configuration.DiContainerBuilder.FileBased.IFileBasedDiContainerConfigurator.WithDiContainer(IoC.Configuration.DiContainer.IDiContainer)" /> only if the application already has a container, and we need to use it.
            </summary>
            <returns>
            Returns an instance of <see cref="T:IoC.Configuration.DiContainerBuilder.FileBased.IFileBasedDiModulesConfigurator" />
            </returns>
        </member>
        <member name="M:IoC.Configuration.DiContainerBuilder.FileBased.FileBasedDiModulesConfigurator.#ctor(IoC.Configuration.DiContainerBuilder.FileBased.FileBasedConfiguration)">
            <summary>
            Initializes a new instance of the <see cref="T:IoC.Configuration.DiContainerBuilder.FileBased.FileBasedDiModulesConfigurator"/> class.
            </summary>
            <param name="fileBasedConfiguration">The file based configuration.</param>
        </member>
        <member name="M:IoC.Configuration.DiContainerBuilder.FileBased.FileBasedDiModulesConfigurator.AddAdditionalDiModules(IoC.Configuration.DiContainer.IDiModule[])">
            <summary>
            Adds the additional <see cref="T:IoC.Configuration.DiContainer.IDiModule"/> modules to be loaded into a container.
            </summary>
            <param name="diModules">The <see cref="T:IoC.Configuration.DiContainer.IDiModule"/> modules to be loaded into a container.</param>
            <returns>Returns an instance of <see cref="T:IoC.Configuration.DiContainerBuilder.FileBased.IFileBasedDiModulesConfigurator"/></returns>
        </member>
        <member name="M:IoC.Configuration.DiContainerBuilder.FileBased.FileBasedDiModulesConfigurator.AddNativeModules(System.Object[])">
            <summary>
            Add native modules, such as Autofac or Ninject modules to be loaded into a container.
            </summary>
            <param name="nativeModules">The native modules, such as Autofac or Ninject modules to be loaded into a container.</param>
            <returns>Returns an instance of <see cref="T:IoC.Configuration.DiContainerBuilder.FileBased.IFileBasedDiModulesConfigurator"/></returns>
        </member>
        <member name="M:IoC.Configuration.DiContainerBuilder.FileBased.FileBasedDiModulesConfigurator.RegisterModules">
            <summary>
            Registers the modules.
            </summary>
            <returns>returns an instance of <see cref="T:IoC.Configuration.DiContainerBuilder.FileBased.IFileBasedContainerStarter"/>.</returns>
        </member>
        <member name="M:IoC.Configuration.DiContainerBuilder.FileBased.IFileBasedContainerStarter.Start">
            <summary>
             Loads the DI container from the configuration file.
            </summary>
            <returns>Returns an instance of <see cref="T:IoC.Configuration.DiContainerBuilder.IContainerInfo"/>.</returns>
        </member>
        <member name="M:IoC.Configuration.DiContainerBuilder.FileBased.IFileBasedDiContainerConfigurator.WithDiContainer(IoC.Configuration.DiContainer.IDiContainer)">
            <summary>
            Will use <see cref="T:IoC.Configuration.DiContainer.IDiContainer"/> instance passed as a parameter when configuring the container.
            Use the method <see cref="M:IoC.Configuration.DiContainerBuilder.FileBased.IFileBasedDiContainerConfigurator.WithDiContainer(IoC.Configuration.DiContainer.IDiContainer)"/> if possible.
            </summary>
            <param name="diContainer">An instance of <see cref="T:IoC.Configuration.DiContainer.IDiContainer"/>.</param>
            <returns>Returns an instance of <see cref="T:IoC.Configuration.DiContainerBuilder.FileBased.IFileBasedDiModulesConfigurator"/></returns>
        </member>
        <member name="M:IoC.Configuration.DiContainerBuilder.FileBased.IFileBasedDiContainerConfigurator.WithoutPresetDiContainer">
            <summary>
                The container will be automatically created. This is the preferred way to build a container.
                Use <see cref="M:IoC.Configuration.DiContainerBuilder.FileBased.IFileBasedDiContainerConfigurator.WithDiContainer(IoC.Configuration.DiContainer.IDiContainer)" /> only if the application already has a container, and we need to use it.
            </summary>
            <returns>Returns an instance of <see cref="T:IoC.Configuration.DiContainerBuilder.FileBased.IFileBasedDiModulesConfigurator"/></returns>
        </member>
        <member name="M:IoC.Configuration.DiContainerBuilder.FileBased.IFileBasedDiModulesConfigurator.AddAdditionalDiModules(IoC.Configuration.DiContainer.IDiModule[])">
            <summary>
            Adds the additional <see cref="T:IoC.Configuration.DiContainer.IDiModule"/> modules to be loaded into a container.
            </summary>
            <param name="diModules">The <see cref="T:IoC.Configuration.DiContainer.IDiModule"/> modules to be loaded into a container.</param>
            <returns>Returns an instance of <see cref="T:IoC.Configuration.DiContainerBuilder.FileBased.IFileBasedDiModulesConfigurator"/></returns>
        </member>
        <member name="M:IoC.Configuration.DiContainerBuilder.FileBased.IFileBasedDiModulesConfigurator.AddNativeModules(System.Object[])">
            <summary>
            Add native modules, such as Autofac or Ninject modules to be loaded into a container.
            </summary>
            <param name="nativeModules">The native modules, such as Autofac or Ninject modules to be loaded into a container.</param>
            <returns>Returns an instance of <see cref="T:IoC.Configuration.DiContainerBuilder.FileBased.IFileBasedDiModulesConfigurator"/></returns>
        </member>
        <member name="M:IoC.Configuration.DiContainerBuilder.FileBased.IRegisterModulesWithDiManagerForFileBasedConfiguration.RegisterModules">
            <summary>
            Registers the modules.
            </summary>
            <returns>returns an instance of <see cref="T:IoC.Configuration.DiContainerBuilder.FileBased.IFileBasedContainerStarter"/>.</returns>
        </member>
        <member name="T:IoC.Configuration.DiContainerBuilder.IContainerInfo">
            <summary>
            Container data for the loaded DI
            </summary>
            <seealso cref="T:IoC.Configuration.DiContainerBuilder.IContainerInfo" />
        </member>
        <member name="P:IoC.Configuration.DiContainerBuilder.IContainerInfo.DiContainer">
            <summary>
            An instance of <see cref="T:IoC.Configuration.DiContainer.IDiContainer"/> for the loaded container.
            </summary>
            <value>
            The di container.
            </value>
        </member>
        <member name="M:IoC.Configuration.DiContainer.BindingConfiguration`1.#ctor(System.Type)">
            <summary>
            Initializes a new instance of the <see cref="T:IoC.Configuration.DiContainer.BindingConfiguration`1"/> class.
            </summary>
            <param name="serviceType">Type of the service.</param>
        </member>
        <member name="M:IoC.Configuration.DiContainer.BindingConfiguration`1.ValidateBeforeImplementationsValidated">
            <summary>
                Override this to do more validation, before implementations are validated
            </summary>
        </member>
        <member name="M:IoC.Configuration.DiContainer.BindingConfiguration`1.AddImplementation(`0)">
            <summary>
            Adds an implementation.
            </summary>
            <param name="bindingImplementationConfiguration">The binding implementation configuration.</param>
        </member>
        <member name="E:IoC.Configuration.DiContainer.BindingConfiguration`1.BindingImplementationConfigurationAdded">
            <summary>
            Occurs when <see cref="M:IoC.Configuration.DiContainer.BindingConfiguration`1.AddImplementation(`0)"/>(TBindingImplementationConfiguration) method is called.
            </summary>
        </member>
        <member name="P:IoC.Configuration.DiContainer.BindingConfiguration`1.Implementations">
            <summary>
            Gets the implementations.
            </summary>
            <value>
            The implementations.
            </value>
        </member>
        <member name="P:IoC.Configuration.DiContainer.BindingConfiguration`1.IsSelfBoundService">
            <summary>
            Gets a value indicating whether this instance is self bound service.
            </summary>
            <value>
              <c>true</c> if this instance is self bound service; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:IoC.Configuration.DiContainer.BindingConfiguration`1.RegisterIfNotRegistered">
            <summary>
            If the value is true, the binding will be registered only if binding for the service <see cref="P:IoC.Configuration.DiContainer.BindingConfiguration`1.ServiceType"/> has not been already registered.
            Note, multiple implementations can still be registered using this binding, if the binding for service was not registered.
            </summary>
        </member>
        <member name="P:IoC.Configuration.DiContainer.BindingConfiguration`1.ServiceType">
            <summary>
            Gets the type of the service.
            </summary>
            <value>
            The type of the service.
            </value>
        </member>
        <member name="M:IoC.Configuration.DiContainer.BindingConfiguration`1.Validate">
            <summary>
            Validates the binding configuration data.
            </summary>
            <exception cref="T:System.Exception">Throws an exception if service binding data is invalid.</exception>
        </member>
        <member name="M:IoC.Configuration.DiContainer.BindingImplementationConfiguration.#ctor(IoC.Configuration.DiContainer.TargetImplementationType,System.Type)">
            <summary>
            Initializes a new instance of the <see cref="T:IoC.Configuration.DiContainer.BindingImplementationConfiguration"/> class.
            </summary>
            <param name="targetImplementationType">Type of the target implementation.</param>
            <param name="implementationType">Type of the implementation.</param>
        </member>
        <member name="P:IoC.Configuration.DiContainer.BindingImplementationConfiguration.TargetImplementationType">
            <summary>
            Gets the type of the target implementation.
            </summary>
            <value>
            The type of the target implementation.
            </value>
        </member>
        <member name="P:IoC.Configuration.DiContainer.BindingImplementationConfiguration.ResolutionScope">
            <summary>
                If not set, will default to <see cref="F:IoC.Configuration.DiContainer.DiResolutionScope.Singleton" />.
            </summary>
        </member>
        <member name="P:IoC.Configuration.DiContainer.BindingImplementationConfiguration.ImplementationType">
            <summary>
            Gets the type of the implementation.
            </summary>
            <value>
            The type of the implementation.
            </value>
        </member>
        <member name="M:IoC.Configuration.DiContainer.BindingImplementationConfiguration.CheckValueNotNullAndSetOnce(System.String,System.Object)">
            <summary>
            Checks the value not null and set once.
            </summary>
            <param name="propertyName">Name of the property.</param>
            <param name="value">The value.</param>
        </member>
        <member name="M:IoC.Configuration.DiContainer.BindingImplementationConfiguration.Validate">
            <summary>
            Validates the binding configuration
            </summary>
            <exception cref="T:System.Exception">
                Throws an exception if service binding data is invalid. Example of invalid data is invalid
                implementation type.
            </exception>
        </member>
        <member name="M:IoC.Configuration.DiContainer.BindingsForCode.Binding.#ctor(IoC.Configuration.DiContainer.BindingsForCode.IServiceRegistrationBuilder,IoC.Configuration.DiContainer.BindingsForCode.BindingConfigurationForCode)">
            <summary>
            Initializes a new instance of the <see cref="T:IoC.Configuration.DiContainer.BindingsForCode.Binding"/> class.
            </summary>
            <param name="serviceRegistrationBuilder">The service registration builder.</param>
            <param name="bindingConfiguration">The binding configuration.</param>
        </member>
        <member name="M:IoC.Configuration.DiContainer.BindingsForCode.BindingConfigurationAddedEventArgs.#ctor(IoC.Configuration.DiContainer.BindingsForCode.BindingConfigurationForCode)">
            <summary>
            Initializes a new instance of the <see cref="T:IoC.Configuration.DiContainer.BindingsForCode.BindingConfigurationAddedEventArgs"/> class.
            </summary>
            <param name="bindingConfiguration">The binding configuration.</param>
        </member>
        <member name="P:IoC.Configuration.DiContainer.BindingsForCode.BindingConfigurationAddedEventArgs.BindingConfiguration">
            <summary>
            Gets the binding configuration.
            </summary>
            <value>
            The binding configuration.
            </value>
        </member>
        <member name="M:IoC.Configuration.DiContainer.BindingsForCode.BindingConfigurationForCode.#ctor(System.Type)">
            <summary>
            Initializes a new instance of the <see cref="T:IoC.Configuration.DiContainer.BindingsForCode.BindingConfigurationForCode"/> class.
            </summary>
            <param name="serviceType">Type of the service.</param>
        </member>
        <member name="M:IoC.Configuration.DiContainer.BindingsForCode.BindingGeneric`1.#ctor(IoC.Configuration.DiContainer.BindingsForCode.IServiceRegistrationBuilder,IoC.Configuration.DiContainer.BindingsForCode.BindingConfigurationForCode)">
            <summary>
            Initializes a new instance of the <see cref="T:IoC.Configuration.DiContainer.BindingsForCode.BindingGeneric`1"/> class.
            </summary>
            <param name="serviceRegistrationBuilder">The service registration builder.</param>
            <param name="bindingConfiguration">The binding configuration.</param>
        </member>
        <member name="M:IoC.Configuration.DiContainer.BindingsForCode.BindingGeneric`1.OnlyIfNotRegistered">
            <summary>
            If called, the binding will be registered only if binding for the service has not been already registered.
            Note, multiple implementations can still be registered using this binding, if the binding for service was not registered.
            </summary>
            <returns>
            Returns <see cref="T:IoC.Configuration.DiContainer.BindingsForCode.IBindingGeneric`1" />
            </returns>
        </member>
        <member name="M:IoC.Configuration.DiContainer.BindingsForCode.BindingGeneric`1.To``1">
            <summary>
            Bind service <typeparamref name="TService" /> to implementation <typeparamref name="TImplementation" />.
            </summary>
            <typeparam name="TImplementation">The type of the implementation.</typeparam>
            <returns>
            Returns <see cref="T:IoC.Configuration.DiContainer.BindingsForCode.IBindingImplementationGeneric`2" />
            </returns>
        </member>
        <member name="M:IoC.Configuration.DiContainer.BindingsForCode.BindingGeneric`1.To(System.Func{IoC.Configuration.DiContainer.IDiContainer,`0})">
            <summary>
            Bind service <typeparamref name="TService" /> to the result of function call <paramref name="resolverFunc" />(<see cref="T:IoC.Configuration.DiContainer.IDiContainer" />).
            </summary>
            <param name="resolverFunc">The resolver function.</param>
            <returns>
            Returns <see cref="T:IoC.Configuration.DiContainer.BindingsForCode.IBindingImplementationGeneric`2" />
            </returns>
        </member>
        <member name="M:IoC.Configuration.DiContainer.BindingsForCode.BindingGeneric`1.To``1(System.Func{IoC.Configuration.DiContainer.IDiContainer,``0})">
            <summary>
            Bind service <typeparamref name="TService" /> to the result of function call <paramref name="resolverFunc" />(<see cref="T:IoC.Configuration.DiContainer.IDiContainer" />).
            TImplementation should be either <typeparamref name="TService" />, or a type that implements or derives from
            <typeparamref name="TService" />.
            Note, we can use value of <typeparamref name="TService" /> for <typeparamref name="TImplementation" /> not to restrict what the function
            <paramref name="resolverFunc" /> returns. In other words to enforce that the implementation returns <typeparamref name="TService" />
            or a subclass or implementation of <typeparamref name="TService" />.
            </summary>
            <typeparam name="TImplementation">The type of the implementation.</typeparam>
            <param name="resolverFunc">The resolver function.</param>
            <returns>
            Returns <see cref="T:IoC.Configuration.DiContainer.BindingsForCode.IBindingImplementationGeneric`2" />
            </returns>
        </member>
        <member name="M:IoC.Configuration.DiContainer.BindingsForCode.BindingGeneric`1.ToSelf">
            <summary>
            Bind service <typeparamref name="TService" /> to itself.
            </summary>
            <returns>
            Returns <see cref="T:IoC.Configuration.DiContainer.BindingsForCode.IBindingImplementationGeneric`2" />
            </returns>
        </member>
        <member name="M:IoC.Configuration.DiContainer.BindingsForCode.BindingImplementation.#ctor(IoC.Configuration.DiContainer.BindingsForCode.IServiceRegistrationBuilder,IoC.Configuration.DiContainer.BindingsForCode.BindingImplementationConfigurationForCode)">
            <summary>
            Initializes a new instance of the <see cref="T:IoC.Configuration.DiContainer.BindingsForCode.BindingImplementation"/> class.
            </summary>
            <param name="serviceRegistrationBuilder">The service registration builder.</param>
            <param name="bindingImplementationConfiguration">The binding implementation configuration.</param>
        </member>
        <member name="M:IoC.Configuration.DiContainer.BindingsForCode.BindingImplementationConfigurationAddedEventArgs`1.#ctor(`0)">
            <summary>
            Initializes a new instance of the <see cref="T:IoC.Configuration.DiContainer.BindingsForCode.BindingImplementationConfigurationAddedEventArgs`1"/> class.
            </summary>
            <param name="bindingImplementationConfiguration">The binding implementation configuration.</param>
        </member>
        <member name="P:IoC.Configuration.DiContainer.BindingsForCode.BindingImplementationConfigurationAddedEventArgs`1.BindingImplementationConfiguration">
            <summary>
            Gets the binding implementation configuration.
            </summary>
            <value>
            The binding implementation configuration.
            </value>
        </member>
        <member name="M:IoC.Configuration.DiContainer.BindingsForCode.BindingImplementationConfigurationForCode.CreateDelegateBasedImplementationConfiguration(System.Type,System.Func{IoC.Configuration.DiContainer.IDiContainer,System.Object})">
            <summary>
            Creates the delegate based implementation configuration.
            </summary>
            <param name="serviceType">Type of the service.</param>
            <param name="implementationGeneratorFunction">The implementation generator function.</param>
            <returns></returns>
        </member>
        <member name="M:IoC.Configuration.DiContainer.BindingsForCode.BindingImplementationConfigurationForCode.CreateSelfImplementationConfiguration(System.Type)">
            <summary>
            Creates the self implementation configuration.
            </summary>
            <param name="serviceType">Type of the service.</param>
            <returns></returns>
        </member>
        <member name="M:IoC.Configuration.DiContainer.BindingsForCode.BindingImplementationConfigurationForCode.CreateTypeBasedImplementationConfiguration(System.Type,System.Type)">
            <summary>
            Creates the type based implementation configuration.
            </summary>
            <param name="serviceType">Type of the service.</param>
            <param name="implementationType">Type of the implementation.</param>
            <returns></returns>
        </member>
        <member name="P:IoC.Configuration.DiContainer.BindingsForCode.BindingImplementationConfigurationForCode.ImplementationGeneratorFunction">
            <summary>
            Gets the implementation generator function.
            </summary>
            <value>
            The implementation generator function.
            </value>
        </member>
        <member name="P:IoC.Configuration.DiContainer.BindingsForCode.BindingImplementationConfigurationForCode.OnImplementationObjectActivated">
            <summary>
                Will be called after the implementation object is activated.
                Use this for property injection.
                The value of <see cref="T:System.Object" /> parameter is the activated implementation instance.
            </summary>
        </member>
        <member name="M:IoC.Configuration.DiContainer.BindingsForCode.BindingImplementationGeneric`2.#ctor(IoC.Configuration.DiContainer.BindingsForCode.IServiceRegistrationBuilder,IoC.Configuration.DiContainer.BindingsForCode.BindingImplementationConfigurationForCode,IoC.Configuration.DiContainer.BindingsForCode.BindingGeneric{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:IoC.Configuration.DiContainer.BindingsForCode.BindingImplementationGeneric`2"/> class.
            </summary>
            <param name="serviceRegistrationBuilder">The service registration builder.</param>
            <param name="bindingImplementationConfiguration">The binding implementation configuration.</param>
            <param name="serviceBinding">The service binding.</param>
        </member>
        <member name="P:IoC.Configuration.DiContainer.BindingsForCode.BindingImplementationGeneric`2.Service">
            <summary>
            Use this member to add multiple implementations for the same service.
            </summary>
        </member>
        <member name="M:IoC.Configuration.DiContainer.BindingsForCode.BindingImplementationGeneric`2.OnImplementationObjectActivated(System.Action{IoC.Configuration.DiContainer.IDiContainer,`1})">
            <summary>
            React to an event that occurs when the implementation is instantiated.
            </summary>
            <param name="onImplementationActivated">The on implementation activated.</param>
            <returns>
            Returns an instance of <see cref="T:IoC.Configuration.DiContainer.BindingsForCode.IBindingImplementationGeneric`2" />
            </returns>
        </member>
        <member name="M:IoC.Configuration.DiContainer.BindingsForCode.BindingImplementationGeneric`2.SetResolutionScope(IoC.Configuration.DiContainer.DiResolutionScope)">
            <summary>
            Sets the resolution scope.
            </summary>
            <param name="resolutionScope">The resolution scope.</param>
            <returns>
            Returns an instance of <see cref="T:IoC.Configuration.DiContainer.BindingsForCode.IBindingImplementationGeneric`2" />
            </returns>
        </member>
        <member name="M:IoC.Configuration.DiContainer.BindingsForCode.BindingImplementationNonGeneric.#ctor(IoC.Configuration.DiContainer.BindingsForCode.IServiceRegistrationBuilder,IoC.Configuration.DiContainer.BindingsForCode.BindingImplementationConfigurationForCode,IoC.Configuration.DiContainer.BindingsForCode.BindingNonGeneric)">
            <summary>
            Initializes a new instance of the <see cref="T:IoC.Configuration.DiContainer.BindingsForCode.BindingImplementationNonGeneric"/> class.
            </summary>
            <param name="serviceRegistrationBuilder">The service registration builder.</param>
            <param name="bindingImplementationConfiguration">The binding implementation configuration.</param>
            <param name="serviceBinding">The service binding.</param>
        </member>
        <member name="P:IoC.Configuration.DiContainer.BindingsForCode.BindingImplementationNonGeneric.Service">
            <summary>
            Use this member to add multiple implementations for the same service.
            </summary>
        </member>
        <member name="M:IoC.Configuration.DiContainer.BindingsForCode.BindingImplementationNonGeneric.OnImplementationObjectActivated(System.Action{IoC.Configuration.DiContainer.IDiContainer,System.Object})">
            <summary>
            React to an event that occurs when the implementation is instantiated.
            </summary>
            <param name="onImplementationActivated"><see cref="T:System.Action" /> that will be executed on implementation activated event.</param>
            <returns>
            Returns an instance of <see cref="T:IoC.Configuration.DiContainer.BindingsForCode.IBindingImplementationNonGeneric" />
            </returns>
        </member>
        <member name="M:IoC.Configuration.DiContainer.BindingsForCode.BindingImplementationNonGeneric.SetResolutionScope(IoC.Configuration.DiContainer.DiResolutionScope)">
            <summary>
            Sets the resolution scope.
            </summary>
            <param name="resolutionScope">The resolution scope.</param>
            <returns></returns>
        </member>
        <member name="M:IoC.Configuration.DiContainer.BindingsForCode.IBindingGeneric`1.OnlyIfNotRegistered">
            <summary>
            If called, the binding will be registered only if binding for the service has not been already registered.
            Note, multiple implementations can still be registered using this binding, if the binding for service was not registered.
            </summary>
            <returns>Returns <see cref="T:IoC.Configuration.DiContainer.BindingsForCode.IBindingGeneric`1"/></returns>
        </member>
        <member name="M:IoC.Configuration.DiContainer.BindingsForCode.IBindingGeneric`1.To``1">
            <summary>
            Bind service <typeparamref name="TService"/> to implementation <typeparamref name="TImplementation"/>.
            </summary>
            <typeparam name="TImplementation">The type of the implementation.</typeparam>
            <returns>Returns <see cref="T:IoC.Configuration.DiContainer.BindingsForCode.IBindingImplementationGeneric`2"/></returns>
        </member>
        <member name="M:IoC.Configuration.DiContainer.BindingsForCode.IBindingGeneric`1.To(System.Func{IoC.Configuration.DiContainer.IDiContainer,`0})">
            <summary>
            Bind the service <typeparamref name="TService"/> to the result of function call <paramref name="resolverFunc"/>(<see cref="T:IoC.Configuration.DiContainer.IDiContainer"/>).
            </summary>
            <param name="resolverFunc">The resolver function.</param>
            <returns>Returns <see cref="T:IoC.Configuration.DiContainer.BindingsForCode.IBindingImplementationGeneric`2"/></returns>
        </member>
        <member name="M:IoC.Configuration.DiContainer.BindingsForCode.IBindingGeneric`1.To``1(System.Func{IoC.Configuration.DiContainer.IDiContainer,``0})">
            <summary>
                Bind service <typeparamref name="TService"/> to the result of function call <paramref name="resolverFunc"/>(<see cref="T:IoC.Configuration.DiContainer.IDiContainer"/>).
                TImplementation should be either <typeparamref name="TService" />, or a type that implements or derives from
                <typeparamref name="TService" />.
                Note, we can use value of <typeparamref name="TService" /> for <typeparamref name="TImplementation"/> not to restrict what the function
                <paramref name="resolverFunc" /> returns. In other words to enforce that the implementation returns <typeparamref name="TService" />
                or a subclass or implementation of <typeparamref name="TService" />.
            </summary>
            <typeparam name="TImplementation">The type of the implementation.</typeparam>
            <param name="resolverFunc">The resolver function.</param>
            <returns>Returns <see cref="T:IoC.Configuration.DiContainer.BindingsForCode.IBindingImplementationGeneric`2"/></returns>
        </member>
        <member name="M:IoC.Configuration.DiContainer.BindingsForCode.IBindingGeneric`1.ToSelf">
            <summary>
            Bind service <typeparamref name="TService"/> to itself.
            </summary>
            <returns>Returns <see cref="T:IoC.Configuration.DiContainer.BindingsForCode.IBindingImplementationGeneric`2"/></returns>
        </member>
        <member name="P:IoC.Configuration.DiContainer.BindingsForCode.IBindingImplementationGeneric`2.Service">
            <summary>
                Use this member to add multiple implementations for the same service.
            </summary>
        </member>
        <member name="M:IoC.Configuration.DiContainer.BindingsForCode.IBindingImplementationGeneric`2.OnImplementationObjectActivated(System.Action{IoC.Configuration.DiContainer.IDiContainer,`1})">
            <summary>
            React to an event that occurs when the implementation is instantiated.
            </summary>
            <param name="onImplementationActivated"><see cref="T:System.Action"/> that will be executed on implementation activated event.</param>
            <returns>Returns an instance of <see cref="T:IoC.Configuration.DiContainer.BindingsForCode.IBindingImplementationGeneric`2"/></returns>
        </member>
        <member name="M:IoC.Configuration.DiContainer.BindingsForCode.IBindingImplementationGeneric`2.SetResolutionScope(IoC.Configuration.DiContainer.DiResolutionScope)">
            <summary>
            Sets the resolution scope.
            </summary>
            <param name="resolutionScope">The resolution scope.</param>
            <returns>Returns an instance of <see cref="T:IoC.Configuration.DiContainer.BindingsForCode.IBindingImplementationGeneric`2"/></returns>
        </member>
        <member name="P:IoC.Configuration.DiContainer.BindingsForCode.IBindingImplementationNonGeneric.Service">
            <summary>
                Use this member to add multiple implementations for the same service.
            </summary>
        </member>
        <member name="M:IoC.Configuration.DiContainer.BindingsForCode.IBindingImplementationNonGeneric.OnImplementationObjectActivated(System.Action{IoC.Configuration.DiContainer.IDiContainer,System.Object})">
            <summary>
            React to an event that occurs when the implementation is instantiated.
            </summary>
            <param name="onImplementationActivated"><see cref="T:System.Action"/> that will be executed on implementation activated event.</param>
            <returns>Returns an instance of <see cref="T:IoC.Configuration.DiContainer.BindingsForCode.IBindingImplementationNonGeneric"/></returns>
        </member>
        <member name="M:IoC.Configuration.DiContainer.BindingsForCode.IBindingImplementationNonGeneric.SetResolutionScope(IoC.Configuration.DiContainer.DiResolutionScope)">
            <summary>
            Sets the resolution scope.
            </summary>
            <param name="resolutionScope">The resolution scope.</param>
            <returns></returns>
        </member>
        <member name="M:IoC.Configuration.DiContainer.BindingsForCode.IBindingNonGeneric.OnlyIfNotRegistered">
            <summary>
            If called, the binding will be registered only if binding for the service has not been already registered.
            Note, multiple implementations can still be registered using this binding, if the binding for service was not registered.
            </summary>
            <returns>Returns <see cref="T:IoC.Configuration.DiContainer.BindingsForCode.IBindingNonGeneric"/></returns>
        </member>
        <member name="M:IoC.Configuration.DiContainer.BindingsForCode.IBindingNonGeneric.To(System.Type)">
            <summary>
            Bind service to implementation of type <paramref name="implementationType"/>.
            </summary>
            <param name="implementationType">The type of the implementation</param>
            <returns>Returns <see cref="T:IoC.Configuration.DiContainer.BindingsForCode.BindingImplementationNonGeneric"/></returns>
        </member>
        <member name="M:IoC.Configuration.DiContainer.BindingsForCode.IBindingNonGeneric.To(System.Func{IoC.Configuration.DiContainer.IDiContainer,System.Object})">
            <summary>
            Bind the service to the result of function call <paramref name="resolverFunc"/>(<see cref="T:IoC.Configuration.DiContainer.IDiContainer"/>).
            </summary>
            <param name="resolverFunc">The resolver function.</param>
            <returns>Returns <see cref="T:IoC.Configuration.DiContainer.BindingsForCode.BindingImplementationNonGeneric"/></returns>
        </member>
        <member name="M:IoC.Configuration.DiContainer.BindingsForCode.IBindingNonGeneric.ToSelf">
            <summary>
            Bind the service  to itself.
            </summary>
            <returns>Returns <see cref="T:IoC.Configuration.DiContainer.BindingsForCode.IBindingImplementationNonGeneric"/></returns>
        </member>
        <member name="M:IoC.Configuration.DiContainer.BindingsForCode.IServiceRegistrationBuilder.Bind``1">
            <summary>
            Creates a generic binding.
            </summary>
            <typeparam name="TService">The type of the service.</typeparam>
            <returns></returns>
        </member>
        <member name="M:IoC.Configuration.DiContainer.BindingsForCode.IServiceRegistrationBuilder.Bind(System.Type)">
            <summary>
            Creates a non-generic binding.
            </summary>
            <param name="serviceType">Type of the service.</param>
            <returns></returns>
        </member>
        <member name="E:IoC.Configuration.DiContainer.BindingsForCode.IServiceRegistrationBuilder.BindingConfigurationAdded">
            <summary>
            Occurs when a binding for service is added.
            </summary>
        </member>
        <member name="M:IoC.Configuration.DiContainer.BindingsForCode.IServiceRegistrationBuilder.HasBinding(System.Type)">
            <summary>
            Determines whether there is a binding for the specified service type.
            </summary>
            <param name="serviceType">Type of the service.</param>
            <returns>
              <c>true</c> if the specified service type has binding; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:IoC.Configuration.DiContainer.BindingsForCode.ServiceRegistrationBuilder.Bind``1">
            <summary>
            Creates a generic binding.
            </summary>
            <typeparam name="TService">The type of the service.</typeparam>
            <returns></returns>
        </member>
        <member name="M:IoC.Configuration.DiContainer.BindingsForCode.ServiceRegistrationBuilder.Bind(System.Type)">
            <summary>
            Creates a non-generic binding.
            </summary>
            <param name="serviceType">Type of the service.</param>
            <returns></returns>
        </member>
        <member name="E:IoC.Configuration.DiContainer.BindingsForCode.ServiceRegistrationBuilder.BindingConfigurationAdded">
            <summary>
            Occurs when a binding for service is added.
            </summary>
        </member>
        <member name="M:IoC.Configuration.DiContainer.BindingsForCode.ServiceRegistrationBuilder.HasBinding(System.Type)">
            <summary>
            Determines whether there is a binding for the specified service type.
            </summary>
            <param name="serviceType">Type of the service.</param>
            <returns>
            <c>true</c> if the specified service type has binding; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="T:IoC.Configuration.DiContainer.BindingsForConfigFile.AssemblyLocator">
            <summary>
            A class for searching and loading assemblies. 
            </summary>
            <seealso cref="T:IoC.Configuration.IAssemblyLocator" />
        </member>
        <member name="M:IoC.Configuration.DiContainer.BindingsForConfigFile.AssemblyLocator.#ctor(System.Func{IoC.Configuration.ConfigurationFile.IConfiguration},System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:IoC.Configuration.DiContainer.BindingsForConfigFile.AssemblyLocator"/> class.
            </summary>
            <param name="getConfugurationFunc">The get confuguration function.</param>
            <param name="entryAssemblyFolder">The entry assembly folder.</param>
        </member>
        <member name="M:IoC.Configuration.DiContainer.BindingsForConfigFile.AssemblyLocator.FindAssemblyPath(System.String,System.String,System.Collections.Generic.IList{System.String}@)">
            <summary>
                Searches for assembly in the following folders among others:
                - Assemblies loaded into current application domain.
                - assemblies in .Net core default folder (example is C:\Program
                Files\dotnet\sdk\NuGetFallbackFolder\microsoft.netcore.app\2.0.0\ref\netcoreapp2.0).
                - assemblies in executable folder.
                - assemblies specified in element iocConfiguration/additionalAssemblyProbingPaths.
                - assemblies specified in element iocConfiguration/plugins for the plugin specified in parameter
                <paramref name="pluginName" />.
            </summary>
            <param name="assemblyName">
                Assembly name. Examples are TestProjects.DynamicallyLoadedAssembly1.dll or
                TestProjects.DynamicallyLoadedAssembly1
            </param>
            <param name="pluginName">
                If the value is not null, the search will be also done in plugin folder of the specified plugin.
                For example if the value of <paramref name="pluginName" /> is "Plugin1", and the value of attribute pluginsDirPath
                in element iocConfiguration/plugins
                is "c:\Plugins", then the folder c:\Plugins\Plugin1 will be searched too.
            </param>
            <param name="searchedDirectories">Returns the list of searched directories.</param>
            <returns>
                Returns the full path of the assembly.
            </returns>
        </member>
        <member name="M:IoC.Configuration.DiContainer.BindingsForConfigFile.AssemblyLocator.FindAssemblyPathInAllPluginFolders(System.String,System.String)">
            <summary>
                This method is similar to <see cref="M:IoC.Configuration.IAssemblyLocator.FindAssemblyPath(System.String,System.String,System.Collections.Generic.IList{System.String}@)" />() in this class, except it searches for assembly in
                all plugin folders, and does not output searched directories.
            </summary>
            <param name="assemblyName"></param>
            <param name="requestingAssemblyFolder">
                If not null, the folder where assembly
                <paramref name="requestingAssemblyFolder" /> is, will be searched as well.
            </param>
            <returns>Returns the full path of the assembly.</returns>
        </member>
        <member name="M:IoC.Configuration.DiContainer.BindingsForConfigFile.AssemblyLocator.LoadAssembly(System.String,System.String)">
            <summary>
            Loads the assembly into application domain, if it is not already loaded.
            Looks for the assembly in number of probing directories (see comments for <see cref="M:IoC.Configuration.DiContainer.BindingsForConfigFile.AssemblyLocator.FindAssemblyPathInAllPluginFolders(System.String,System.String)" />
            and <see cref="M:IoC.Configuration.IAssemblyLocator.FindAssemblyPath(System.String,System.String,System.Collections.Generic.IList{System.String}@)" /> for more details on how the assembly is searched).
            </summary>
            <param name="assemblyNameWithExtension">Assembly file name without extension. Examples is "TestProjects.DynamicallyLoadedAssembly1".</param>
            <param name="assemblyFolder">If the value is not null and is not an empty string, the assembly will be loaded from this folder.
            Otherwise, assembly will be searched in multiple directories by name.</param>
            <returns>
            Returns the loaded assembly.
            </returns>
            <exception cref="T:System.Exception">Throws an exception the assembly was not found, or if the assembly fails to get loaded.</exception>
        </member>
        <member name="M:IoC.Configuration.DiContainer.BindingsForConfigFile.BindingConfigurationForFile.CreateBindingConfigurationForFile(System.Type,System.Boolean,System.Collections.Generic.IEnumerable{IoC.Configuration.ConfigurationFile.IServiceImplementationElement})">
            <summary>
            Creates the binding configuration for file.
            </summary>
            <param name="serviceType">Type of the service.</param>
            <param name="registerOnlyIfNotRegistered">if set to <c>true</c> [register only if not registered].</param>
            <param name="serviceImplementations">The service implementations.</param>
            <returns></returns>
        </member>
        <member name="M:IoC.Configuration.DiContainer.BindingsForConfigFile.BindingImplementationConfigurationForFile.#ctor(IoC.Configuration.ConfigurationFile.IServiceImplementationElement)">
            <summary>
            Initializes a new instance of the <see cref="T:IoC.Configuration.DiContainer.BindingsForConfigFile.BindingImplementationConfigurationForFile"/> class.
            </summary>
            <param name="serviceImplementationElement">The service implementation element.</param>
            <exception cref="T:System.Exception">
            </exception>
        </member>
        <member name="P:IoC.Configuration.DiContainer.BindingsForConfigFile.BindingImplementationConfigurationForFile.InjectedProperties">
            <summary>
            Gets the injected properties.
            </summary>
            <value>
            The injected properties.
            </value>
        </member>
        <member name="P:IoC.Configuration.DiContainer.BindingsForConfigFile.BindingImplementationConfigurationForFile.Parameters">
            <summary>
                If the value is null, the parameters will be injected.
                Otherwise, a constructor which matches the parameters by type and name will
                be used to create an implementation.
            </summary>
        </member>
        <member name="M:IoC.Configuration.DiContainer.BindingsForConfigFile.InjectedProperty.#ctor(IoC.Configuration.ConfigurationFile.IInjectedPropertyElement)">
            <summary>
            Initializes a new instance of the <see cref="T:IoC.Configuration.DiContainer.BindingsForConfigFile.InjectedProperty"/> class.
            </summary>
            <param name="injectedPropertyElement">The injected property element.</param>
        </member>
        <member name="M:IoC.Configuration.DiContainer.BindingsForConfigFile.NamedValue.#ctor(IoC.Configuration.ConfigurationFile.INamedValueElement)">
            <summary>
            Initializes a new instance of the <see cref="T:IoC.Configuration.DiContainer.BindingsForConfigFile.NamedValue"/> class.
            </summary>
            <param name="namedValueElement">The named value element.</param>
        </member>
        <member name="P:IoC.Configuration.DiContainer.BindingsForConfigFile.NamedValue.Name">
            <summary>
            Gets the name.
            </summary>
            <value>
            The name.
            </value>
        </member>
        <member name="P:IoC.Configuration.DiContainer.BindingsForConfigFile.NamedValue.ValueAsString">
            <summary>
            Gets the value as string. Examples are "2", "true", etc.
            </summary>
            <value>
            The value as string.
            </value>
        </member>
        <member name="P:IoC.Configuration.DiContainer.BindingsForConfigFile.NamedValue.ValueInstantiationType">
            <summary>
            Normally for injectedObject element this value is <see cref="F:IoC.Configuration.ValueInstantiationType.ResolveFromDiContext" />, for
            other elements (i.e., int16, int32, etc), the overridden value will be <see cref="F:IoC.Configuration.ValueInstantiationType.DeserializeFromStringValue" />
            </summary>
        </member>
        <member name="P:IoC.Configuration.DiContainer.BindingsForConfigFile.NamedValue.ValueType">
            <summary>
            Can be null only if the parameter is declared with either 'object' or injectedObject elements, and the object type
            referenced is in a disabled assembly.
            </summary>
        </member>
        <member name="M:IoC.Configuration.DiContainer.BindingsForConfigFile.Parameter.#ctor(IoC.Configuration.ConfigurationFile.IParameterElement)">
            <summary>
            Initializes a new instance of the <see cref="T:IoC.Configuration.DiContainer.BindingsForConfigFile.Parameter"/> class.
            </summary>
            <param name="parameterElement">The parameter element.</param>
        </member>
        <member name="T:IoC.Configuration.DiContainer.DiManagerImplementationHelper">
            <summary>
            A helper class that specific implementations (such as Autofac or Ninject) can use.
            </summary>
        </member>
        <member name="M:IoC.Configuration.DiContainer.DiManagerImplementationHelper.AddCodeForOnDiContainerReadyMethod(System.Text.StringBuilder)">
            <summary>
            Adds the code for on di container ready method.
            </summary>
            <param name="moduleClassContents">The module class contents.</param>
        </member>
        <member name="M:IoC.Configuration.DiContainer.DiManagerImplementationHelper.GenerateCodeForDeserializedParameterValue(IoC.Configuration.INamedValue)">
            <summary>
            Generates the code for deserialized parameter value.
            </summary>
            <param name="namedValue">The named value.</param>
            <returns></returns>
        </member>
        <member name="M:IoC.Configuration.DiContainer.DiManagerImplementationHelper.ThrowUnsuportedEnumerationValue(System.Enum)">
            <summary>
            Throws the unsuported enumeration value.
            </summary>
            <param name="enumValue">The enum value.</param>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="M:IoC.Configuration.DiContainer.DiManagerImplementationHelper.ThrowUnsupportedFeature(IoC.Configuration.DiContainer.NonStandardFeatures,IoC.Configuration.DiContainer.IDiManager)">
            <summary>
                Throws n exception, if the feature specified in parameter <paramref name="nonStandardFeatures" /> is not supported
                by container implementation specified in parameter <paramref name="diManager" />.
            </summary>
            <param name="nonStandardFeatures"></param>
            <param name="diManager"></param>
            <exception cref="T:System.Exception">Always throws this exception.</exception>
        </member>
        <member name="M:IoC.Configuration.DiContainer.DiManagerImplementationHelper.ThrowUnsupportedResolutionScope(IoC.Configuration.DiContainer.BindingsForConfigFile.BindingImplementationConfigurationForFile)">
            <summary>
                Throw an exception, if the value of <see cref="P:IoC.Configuration.ConfigurationFile.IServiceImplementationElement.ResolutionScope" /> is unsupported by
                the implementation of <see cref="T:IoC.Configuration.DiContainer.IDiManager" />.
            </summary>
            <param name="serviceImplementationElement"></param>
            <exception cref="T:System.Exception">Always throws this exception.</exception>
        </member>
        <member name="T:IoC.Configuration.DiContainer.IDiContainer">
            <summary>
            A DI container abstraction used to resolve services. An example implementations of this interface can be found in
            IoC.Configuration.Autofac and IoC.Configuration.Ninject Nuget packages. 
            </summary>
            <seealso cref="T:System.IDisposable" />
        </member>
        <member name="P:IoC.Configuration.DiContainer.IDiContainer.CurrentLifeTimeScope">
            <summary>
            Gets the current life time scope.
            </summary>
            <value>
            The current life time scope.
            </value>
        </member>
        <member name="P:IoC.Configuration.DiContainer.IDiContainer.MainLifeTimeScope">
            <summary>
            Gets the main life time scope.
            </summary>
            <value>
            The main life time scope.
            </value>
        </member>
        <member name="M:IoC.Configuration.DiContainer.IDiContainer.Resolve``1">
            <summary>
                Resolved the type using the life time scope <see cref="P:IoC.Configuration.DiContainer.IDiContainer.CurrentLifeTimeScope" />.
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:IoC.Configuration.DiContainer.IDiContainer.Resolve(System.Type)">
            <summary>
                Resolved the type using the life time scope <see cref="P:IoC.Configuration.DiContainer.IDiContainer.CurrentLifeTimeScope" />.
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:IoC.Configuration.DiContainer.IDiContainer.Resolve``1(IoC.Configuration.DiContainer.ILifeTimeScope)">
            <summary>
                Sets the value of <see cref="P:IoC.Configuration.DiContainer.IDiContainer.CurrentLifeTimeScope" /> to the value of parameter
                <paramref name="lifeTimeScope" />,
                resolved the object using<paramref name="lifeTimeScope" />, and restores the value of
                <see cref="P:IoC.Configuration.DiContainer.IDiContainer.CurrentLifeTimeScope" /> to its
                previous value, after the type resolution is complete.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="lifeTimeScope"></param>
            <returns></returns>
        </member>
        <member name="M:IoC.Configuration.DiContainer.IDiContainer.Resolve(System.Type,IoC.Configuration.DiContainer.ILifeTimeScope)">
            <summary>
                Sets the value of <see cref="P:IoC.Configuration.DiContainer.IDiContainer.CurrentLifeTimeScope" /> to the value of parameter <paramref name="lifeTimeScope" />,
                resolved the object using <paramref name="lifeTimeScope" />, and restores the value of
                <see cref="P:IoC.Configuration.DiContainer.IDiContainer.CurrentLifeTimeScope" /> to its
                previous value, after the type resolution is complete.
            </summary>
            <param name="type"></param>
            <param name="lifeTimeScope"></param>
            <returns></returns>
        </member>
        <member name="M:IoC.Configuration.DiContainer.IDiContainer.StartLifeTimeScope">
            <summary>
            Starts a new life time scope.
            </summary>
            <returns></returns>
        </member>
        <member name="M:IoC.Configuration.DiContainer.IDiContainer.StartMainLifeTimeScope">
            <summary>
                Starts a new life time scope and assigns it to <see cref="P:IoC.Configuration.DiContainer.IDiContainer.MainLifeTimeScope" />.
            </summary>
        </member>
        <member name="M:IoC.Configuration.DiContainer.IDiManager.BuildServiceProvider(IoC.Configuration.DiContainer.IDiContainer,System.Collections.Generic.IEnumerable{System.Object})">
            <summary>
            This method registers modules with service provider.
            </summary>
            <param name="diContainer">The DI container.</param>
            <param name="modules">The modules to register.</param>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:IoC.Configuration.DiContainer.IDiManager.CreateDiContainer">
            <summary>
                Creates a native container object of type <see cref="T:IoC.Configuration.DiContainer.IDiContainer" />. The object can be used to pass as a
                parameter in class constructors, however it might not be in a state to be used to resolve services.
                Before services can be resolved, call the method <see cref="M:IoC.Configuration.DiContainer.IDiManager.BuildServiceProvider(IoC.Configuration.DiContainer.IDiContainer,System.Collections.Generic.IEnumerable{System.Object})" /> and then <see cref="M:IoC.Configuration.DiContainer.IDiManager.StartServiceProvider(IoC.Configuration.DiContainer.IDiContainer)"/>.
            </summary>
            <returns></returns>
        </member>
        <member name="P:IoC.Configuration.DiContainer.IDiManager.DiContainerName">
            <summary>
            DI container name, such as Autofac or Nnject.
            </summary>
        </member>
        <member name="M:IoC.Configuration.DiContainer.IDiManager.GenerateModuleClassCode(OROptimizer.DynamicCode.IDynamicAssemblyBuilder,IoC.Configuration.IAssemblyLocator,System.String,System.String,System.Collections.Generic.IEnumerable{IoC.Configuration.DiContainer.BindingsForConfigFile.BindingConfigurationForFile})">
            <summary>
                Generates a C# file contents for a native module, such as Autofac or Ninject module.
                The generated class should have a parameterless constructor. If the generated module class has a public
                method <see cref="F:IoC.Configuration.HelpersIoC.OnDiContainerReadyMethodName" />(IoC.Configuration.DiContainer.IDiContainer diContainer),
                it will be executed with a parameter <see cref="T:IoC.Configuration.DiContainer.IDiContainer" /> when the container is ready to resolve services.
            </summary>
            <param name="dynamicAssemblyBuilder">
            The dynamic assembly builder.
            The implementation can use this parameter to add referenced files to dynamically generated assembly which will contain the generated module class.
            </param>
            <param name="assemblyLocator">The assembly locator.</param>
            <param name="moduleClassNamespace">The module class namespace.</param>
            <param name="moduleClassName">Name of the module class.</param>
            <param name="moduleServiceConfigurationElements">Collection of all binding configurations for services to use when building the module.</param>
            <returns>Returns a C# file contents for a native module, such as Autofac or Ninject module.</returns>
            <exception cref="T:System.Exception">Throw this exception if module fails to get generated.</exception>
        </member>
        <member name="M:IoC.Configuration.DiContainer.IDiManager.GenerateNativeModule(IoC.Configuration.DiContainer.IDiModule)">
            <summary>
                This class takes an object of type <see cref="T:IoC.Configuration.DiContainer.IDiModule" />  and converts it to
                a native module of some DI container, such as Autofac or Ninject module.
            </summary>
            <param name="module"></param>
            <returns>Returns a native DI module such an Autofac Module class object.</returns>
        </member>
        <member name="M:IoC.Configuration.DiContainer.IDiManager.GetRequiredBindingsModule">
            <summary>
                Returns a module object, such as Autofac or Ninjectmodule, which sets all the requierd binding.
                For example this module can add binding for <see cref="T:IoC.Configuration.DiContainer.IDiContainer" /> among other things.
            </summary>
            <returns></returns>
        </member>
        <member name="P:IoC.Configuration.DiContainer.IDiManager.ModuleType">
            <summary>
                For example for Autofac based implementation of <see cref="P:IoC.Configuration.DiContainer.IDiManager.ModuleType" /> will return type of Autofac.Module.
            </summary>
        </member>
        <member name="M:IoC.Configuration.DiContainer.IDiManager.StartServiceProvider(IoC.Configuration.DiContainer.IDiContainer)">
            <summary>
                Starts the container. After this method is called,  calls to <see cref="M:IoC.Configuration.DiContainer.IDiContainer.Resolve(System.Type)" /> can be made
                to resolve services.
            </summary>
            <param name="diContainer">Dependency injection container to start.</param>
        </member>
        <member name="T:IoC.Configuration.DiContainer.IDiModule">
            <summary>
                Look at <see cref="T:IoC.Configuration.DiContainer.ModuleAbstr" /> for implementation example for this method.
                Normally, one would subclass from <see cref="T:IoC.Configuration.DiContainer.ModuleAbstr" /> and override the method
                <see cref="M:IoC.Configuration.DiContainer.ModuleAbstr.AddServiceRegistrations" />.
                Within the body of <see cref="M:IoC.Configuration.DiContainer.ModuleAbstr.AddServiceRegistrations" />, one can use statements like:
                Bind &lt;IService1&gt;().OnlyIfNotRegistered().To&lt;Service1&gt;
                ().SetResolutionScope(DiResolutionScope.Singleton);
            </summary>
        </member>
        <member name="M:IoC.Configuration.DiContainer.IDiModule.Init(IoC.Configuration.DiContainer.BindingsForCode.IServiceRegistrationBuilder)">
            <summary>
            Initializes the specified service registration builder.
            </summary>
            <param name="serviceRegistrationBuilder">The service registration builder.</param>
        </member>
        <member name="M:IoC.Configuration.DiContainer.IDiModule.Load">
            <summary>
                Adds bindings and validates the added bindings.
            </summary>
        </member>
        <member name="P:IoC.Configuration.DiContainer.IDiModule.ServiceBindingConfigurations">
            <summary>
            Gets the service binding configurations.
            </summary>
            <value>
            The service binding configurations.
            </value>
        </member>
        <member name="E:IoC.Configuration.DiContainer.ILifeTimeScope.LifeTimeScopeTerminated">
            <summary>
            Occurs when current life time scope is terminated. Example of using this event is as follows:
            <see cref="T:IoC.Configuration.DiContainer.IDiContainer"/> diContainer;
            diContainer.MainLifeTimeScope.LifeTimeScopeTerminated += (sender, e) => { // do something. }
            </summary>
        </member>
        <member name="T:IoC.Configuration.DiContainer.LifeTimeScopeStandard">
            <summary>
            Default implementation of <see cref="T:IoC.Configuration.DiContainer.ILifeTimeScope"/>.
            </summary>
            <seealso cref="T:IoC.Configuration.DiContainer.ILifeTimeScope" />
        </member>
        <member name="E:IoC.Configuration.DiContainer.LifeTimeScopeStandard.LifeTimeScopeTerminated">
            <summary>
            Occurs when current life time scope is terminated. Example of using this event is as follows:
            <see cref="T:IoC.Configuration.DiContainer.IDiContainer" /> diContainer;
            diContainer.MainLifeTimeScope.LifeTimeScopeTerminated += (sender, e) =&gt; { // do something. }
            </summary>
        </member>
        <member name="M:IoC.Configuration.DiContainer.LifeTimeScopeStandard.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
        </member>
        <member name="T:IoC.Configuration.DiContainer.ModuleAbstr">
            <summary>
                Normally, one would subclass from <see cref="T:IoC.Configuration.DiContainer.ModuleAbstr" /> and override the method
                <see cref="M:IoC.Configuration.DiContainer.ModuleAbstr.AddServiceRegistrations" />.
                Within the body of <see cref="M:IoC.Configuration.DiContainer.ModuleAbstr.AddServiceRegistrations" />, one can use statements like:
                Bind &lt;IService1&gt;().OnlyIfNotRegistered().To&lt;Service1&gt;
                ().SetResolutionScope(DiResolutionScope.Singleton);
            </summary>
        </member>
        <member name="M:IoC.Configuration.DiContainer.ModuleAbstr.AddServiceRegistrations">
            <summary>
                Override this method to register services. The body of overridden method might have statements like:
                Bind &lt;IService1&gt;().OnlyIfNotRegistered().To&lt;Service1&gt;
                ().SetResolutionScope(DiResolutionScope.Singleton);
            </summary>
        </member>
        <member name="M:IoC.Configuration.DiContainer.ModuleAbstr.Load">
            <summary>
            Adds bindings and validates the added bindings.
            </summary>
        </member>
        <member name="M:IoC.Configuration.DiContainer.ModuleAbstr.Bind``1">
            <summary>
            Creates a binding for service <typeparamref name="TService"/>.
            </summary>
            <typeparam name="TService">The type of the service.</typeparam>
            <returns></returns>
        </member>
        <member name="M:IoC.Configuration.DiContainer.ModuleAbstr.Bind(System.Type)">
            <summary>
            Creates a binding for service <paramref name="serviceType"/>.
            </summary>
            <param name="serviceType">Type of the service.</param>
            <returns></returns>
        </member>
        <member name="F:IoC.Configuration.DiContainer.NonStandardFeatures.RegisterServiceWithSingleImplementationsOnlyIfServiceNotRegistered">
            <summary>
                Allows registering a service, only if the service is not registered, when there is only one implementation for the
                service.
            </summary>
        </member>
        <member name="F:IoC.Configuration.DiContainer.NonStandardFeatures.RegisterServiceWithMultipleImplementationsOnlyIfServiceNotRegistered">
            <summary>
                Allows registering a service, only if the service is not registered, when multiple implementations are registered
                for the service.
                The specific IoC container (e.g., Autofac, Ninject, etc),
                should support registering multiple implementations of the service, if the service was not registered.
                For example Autofac currently supports this for single implementation (using IfNotRegistered(Type)), but there is
                no way to do this for
                multiple implementations of a service (i.e., check if service was registered, and register all implementations if
                it was not).
            </summary>
        </member>
        <member name="F:IoC.Configuration.DiContainer.NonStandardFeatures.WhenInjectedIntoClassOrSubClassesConditionalInjection">
            <summary>
                Specific implementation will be applied only if the implementation is injected into a specific type or its
                subclasses.
            </summary>
        </member>
        <member name="F:IoC.Configuration.DiContainer.NonStandardFeatures.WhenInjectedExactlyIntoClassConditionalInjection">
            <summary>
                Specific implementation will be applied only if the implementation is injected into a specific type.
            </summary>
        </member>
        <member name="F:IoC.Configuration.DiContainer.TargetImplementationType.Self">
            <summary>
                Service is bound to its own type
            </summary>
        </member>
        <member name="F:IoC.Configuration.DiContainer.TargetImplementationType.Type">
            <summary>
                Type of implementation
            </summary>
        </member>
        <member name="F:IoC.Configuration.DiContainer.TargetImplementationType.Delegate">
            <summary>
                A delegate that returns implementation object
            </summary>
        </member>
        <member name="M:IoC.Configuration.DynamicCode.ITypesListFactoryTypeGenerator.GenerateType(OROptimizer.DynamicCode.IDynamicAssemblyBuilder,System.Type,System.String,System.Collections.Generic.IEnumerable{System.Type},System.Collections.Generic.IEnumerable{System.String[]},System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{System.Type}})">
            <summary>
                Generates a C# file for a type that is an implementation of interface specified in
                <paramref name="interfaceToImplement" /> parameter.
                Calls <see cref="M:OROptimizer.DynamicCode.IDynamicAssemblyBuilder.AddCSharpFile(System.String)" /> to add the generated C# file to an assembly being
                built.
                Interface <paramref name="interfaceToImplement" /> should have exactly one method that has arbitrary number
                of parameters, and returns <see cref="T:System.Collections.Generic.IEnumerable`1" />, where T is an interface.
            </summary>
            <param name="dynamicAssemblyBuilder">The dynamic assembly builder.</param>
            <param name="interfaceToImplement">The interface to implement.</param>
            <param name="dynamicImplementationsNamespace">Namespace to use for generated classes.</param>
            <param name="returnedInstanceTypesForDefaultCase">The returned instance types for default case.</param>
            <param name="selectorParameterValues">The selector parameter values.</param>
            <param name="returnedInstanceTypesForSelectorParameterValues">The returned instance types for selector parameter values.</param>
            <returns>Returns generated type information, such as class full name and C# file contents.</returns>
            /// <exception cref="T:System.Exception">Throws exception if the implementation generation fails.</exception>
        </member>
        <member name="M:IoC.Configuration.DynamicCode.ITypesListFactoryTypeGenerator.ValidateImplementedInterface(System.Type,System.Reflection.MethodInfo@,System.Type@,System.String@)">
            <summary>
            Validates the implemented interface.
            </summary>
            <param name="interfaceToImplement">The interface to implement.</param>
            <param name="implementedMethodInfo">The implemented method information.</param>
            <param name="returnedItemsType">Type of the returned items.</param>
            <param name="errorMessage">The error message.</param>
            <returns></returns>
        </member>
        <member name="M:IoC.Configuration.DynamicCode.ITypesListFactoryTypeGenerator.ValidateParameterValues(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.String},System.String@)">
            <summary>
            Validates the parameter values.
            </summary>
            <param name="implementedMethodInfo">The implemented method information.</param>
            <param name="selectorParameterValues">The selector parameter values.</param>
            <param name="errorMessage">The error message.</param>
            <returns></returns>
        </member>
        <member name="M:IoC.Configuration.DynamicCode.ITypesListFactoryTypeGenerator.ValidateReturnedType(System.Type,System.Type,System.String@)">
            <summary>
            Validates the type of the returned.
            </summary>
            <param name="specifiedReturnedType">Specified type of the returned.</param>
            <param name="returnedItemsType">Type of the returned items.</param>
            <param name="errorMessage">The error message.</param>
            <returns></returns>
        </member>
        <member name="M:IoC.Configuration.DynamicCode.TypesListFactoryTypeGenerator.GenerateType(OROptimizer.DynamicCode.IDynamicAssemblyBuilder,System.Type,System.String,System.Collections.Generic.IEnumerable{System.Type},System.Collections.Generic.IEnumerable{System.String[]},System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{System.Type}})">
            <summary>
            Generates a C# file for a type that is an implementation of interface specified in
            <paramref name="interfaceToImplement" /> parameter.
            Calls <see cref="M:OROptimizer.DynamicCode.IDynamicAssemblyBuilder.AddCSharpFile(System.String)" /> to add the generated C# file to an assembly being
            built.
            Interface <paramref name="interfaceToImplement" /> should have exactly one method that has arbitrary number
            of parameters, and returns <see cref="T:System.Collections.Generic.IEnumerable`1" />, where T is an interface.
            </summary>
            <param name="dynamicAssemblyBuilder">The dynamic assembly builder.</param>
            <param name="interfaceToImplement">The interface to implement.</param>
            <param name="dynamicImplementationsNamespace">Namespace to use for generated classes.</param>
            <param name="returnedInstanceTypesForDefaultCase">The returned instance types for default case.</param>
            <param name="selectorParameterValues">The selector parameter values.</param>
            <param name="returnedInstanceTypesForSelectorParameterValues">The returned instance types for selector parameter values.</param>
            <returns>
            Returns generated type information, such as class full name and C# file contents.
            </returns>
            <exception cref="T:System.Exception">
            selectorParameterValues
            or
            </exception>
        </member>
        <member name="M:IoC.Configuration.DynamicCode.TypesListFactoryTypeGenerator.ValidateImplementedInterface(System.Type,System.Reflection.MethodInfo@,System.Type@,System.String@)">
            <summary>
            Validates the implemented interface.
            </summary>
            <param name="interfaceToImplement">The interface to implement.</param>
            <param name="implementedMethodInfo">The implemented method information.</param>
            <param name="returnedItemsType">Type of the returned items.</param>
            <param name="errorMessage">The error message.</param>
            <returns></returns>
        </member>
        <member name="M:IoC.Configuration.DynamicCode.TypesListFactoryTypeGenerator.ValidateParameterValues(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.String},System.String@)">
            <summary>
            Validates the parameter values.
            </summary>
            <param name="implementedMethodInfo">The implemented method information.</param>
            <param name="selectorParameterValues">The selector parameter values.</param>
            <param name="errorMessage">The error message.</param>
            <returns></returns>
        </member>
        <member name="M:IoC.Configuration.DynamicCode.TypesListFactoryTypeGenerator.ValidateReturnedType(System.Type,System.Type,System.String@)">
            <summary>
            Validates the type of the returned.
            </summary>
            <param name="specifiedReturnedType">Specified type of the returned.</param>
            <param name="returnedItemsType">Type of the returned items.</param>
            <param name="errorMessage">The error message.</param>
            <returns></returns>
        </member>
        <member name="T:IoC.Configuration.FileBasedConfigurationFileContentsProvider">
            <summary>
                An implementation of <see cref="T:IoC.Configuration.IConfigurationFileContentsProvider"/>, that loads configuration file contents form a file
            </summary>
            <seealso cref="T:IoC.Configuration.IConfigurationFileContentsProvider"/>
        </member>
        <member name="M:IoC.Configuration.FileBasedConfigurationFileContentsProvider.#ctor(System.String)">
            <summary>
                A constructor.
            </summary>
            <param name="configurationFilePath"></param>
        </member>
        <member name="M:IoC.Configuration.FileBasedConfigurationFileContentsProvider.LoadConfigurationFileContents">
            <summary>
            Returns IoC configuration file content as a string. The content should be a valid XML document and
            should be successfully validated using the schema file IoC.Configuration.Schema.2F7CE7FF-CB22-40B0-9691-EAC689C03A36.xsd.
            </summary>
            <returns>
            Returns a <see cref="T:System.IO.Stream" /> object for the configuration file contents.
            </returns>
            <exception cref="T:System.Exception">File failed to load.</exception>
        </member>
        <member name="T:IoC.Configuration.IAssemblyLocator">
            <summary>
            A class for searching and loading assemblies. 
            </summary>
        </member>
        <member name="M:IoC.Configuration.IAssemblyLocator.FindAssemblyPath(System.String,System.String,System.Collections.Generic.IList{System.String}@)">
            <summary>
                Searches for assembly. Also, look at the comments for this method in implementation <seealso cref="T:IoC.Configuration.DiContainer.BindingsForConfigFile.AssemblyLocator"/>.
                The implementation might search for the assembly in the following locations:
                - Assemblies loaded into current application domain.
                - assemblies in .Net core default folder (example is C:\Program Files\dotnet\sdk\NuGetFallbackFolder\microsoft.netcore.app\2.0.0\ref\netcoreapp2.0).
                - assemblies in executable folder.
                - assemblies specified in element iocConfiguration/additionalAssemblyProbingPaths.
                - assemblies specified in element iocConfiguration/plugins for the plugin specified in parameter <paramref name="pluginName" />.
            </summary>
            <param name="assemblyName">Assembly name. Examples are TestProjects.DynamicallyLoadedAssembly1.dll or TestProjects.DynamicallyLoadedAssembly1</param>
            <param name="pluginName">
                If the value is not null, the search will be also done in plugin folder of the specified plugin.
                For example if the value of <paramref name="pluginName"/> is "Plugin1", and the value of attribute pluginsDirPath in element iocConfiguration\plugins
                is "c:\Plugins", then the folder c:\Plugins\Plugin1 will be searched too.
            </param>
            <param name="searchedDirectories">Returns the list of searched directories.</param>
            <returns>Returns the full path of the assembly.</returns>
        </member>
        <member name="M:IoC.Configuration.IAssemblyLocator.FindAssemblyPathInAllPluginFolders(System.String,System.String)">
            <summary>
                This method is similar to <see cref="M:IoC.Configuration.IAssemblyLocator.FindAssemblyPath(System.String,System.String,System.Collections.Generic.IList{System.String}@)"/>() in this class, except it searches for assembly in
                all plugin folders, and does not output searched directories.
            </summary>
            <param name="assemblyName"></param>
            <param name="requestingAssemblyFolder">If not null, the folder where assembly <paramref name="requestingAssemblyFolder"/> is, will be searched as well.</param>
            <returns>Returns the full path of the assembly.</returns>
        </member>
        <member name="M:IoC.Configuration.IAssemblyLocator.LoadAssembly(System.String,System.String)">
            <summary>
                Loads the assembly into application domain, if it is not already loaded.
                Looks for the assembly in number of probing directories (see comments for <see cref="M:IoC.Configuration.IAssemblyLocator.FindAssemblyPathInAllPluginFolders(System.String,System.String)"/>
                and <see cref="M:IoC.Configuration.IAssemblyLocator.FindAssemblyPath(System.String,System.String,System.Collections.Generic.IList{System.String}@)"/> for more details on how the assembly is searched).
            </summary>
            <param name="assemblyNameWithExtension">Assembly file name without extension. Examples is "TestProjects.DynamicallyLoadedAssembly1".</param>
            <param name="assemblyFolder">
                If the value is not null and is not an empty string, the assembly will be loaded from this folder.
                Otherwise, assembly will be searched in multiple directories by name.
            </param>
            <returns>Returns the loaded assembly.</returns>
            <exception cref="T:System.Exception">Throws an exception the assembly was not found, or if the assembly fails to get loaded.</exception>
        </member>
        <member name="T:IoC.Configuration.IConfigurationFileContentsProvider">
            <summary>
                An interface that provides IoC configuration file content.
            </summary>
        </member>
        <member name="P:IoC.Configuration.IConfigurationFileContentsProvider.ConfigurationFileSourceDetails">
            <summary>
                Some details of the source, where the configuration file contents are loaded from. Examples are: file path or
                database record id, that has the configuration. The value of this property might be used for diagnostics purposes,
                if the configuration fails to be loaded. 
            </summary>
        </member>
        <member name="M:IoC.Configuration.IConfigurationFileContentsProvider.LoadConfigurationFileContents">
            <summary>
                Returns IoC configuration file content as a string. The content should be a valid XML document and
                should be successfully validated using the schema file IoC.Configuration.Schema.2F7CE7FF-CB22-40B0-9691-EAC689C03A36.xsd.
            </summary>
            <returns>Returns a <see cref="T:System.IO.Stream" /> object for the configuration file contents.</returns>
            <exception cref="T:System.Exception">Throws an exception if the stream fails to be created.</exception>
        </member>
        <member name="T:IoC.Configuration.IIoCServiceFactory">
            <summary>
            A service factory.
            </summary>
        </member>
        <member name="M:IoC.Configuration.IIoCServiceFactory.CreateAssemblyLocator(System.Func{IoC.Configuration.ConfigurationFile.IConfiguration},System.String)">
            <summary>
                Creates an instance of <see cref="T:IoC.Configuration.IAssemblyLocator" />.
            </summary>
            <param name="getConfugurationFunc">
                A <see cref="T:System.Func`1" /> objects that returns an instance of
                <see cref="T:IoC.Configuration.ConfigurationFile.IConfiguration" />
            </param>
            <param name="entryAssemblyFolder"></param>
        </member>
        <member name="M:IoC.Configuration.IIoCServiceFactory.CreateTypesListFactoryTypeGenerator(OROptimizer.Serializer.ITypeBasedSimpleSerializerAggregator)">
            <summary>
                Creates an instance of <see cref="T:IoC.Configuration.DynamicCode.ITypesListFactoryTypeGenerator" />
            </summary>
        </member>
        <member name="M:IoC.Configuration.IIoCServiceFactory.GetProhibitedServiceTypesInServicesElementChecker">
            <summary>
                Returns instance of <see cref="T:IoC.Configuration.ConfigurationFile.IProhibitedServiceTypesInServicesElementChecker" />.
            </summary>
        </member>
        <member name="P:IoC.Configuration.INamedItem.Name">
            <summary>
            Gets the name.
            </summary>
            <value>
            The name.
            </value>
        </member>
        <member name="P:IoC.Configuration.INamedValue.ValueAsString">
            <summary>
            Gets the value as string. Examples are "2", "true", etc.
            </summary>
            <value>
            The value as string.
            </value>
        </member>
        <member name="P:IoC.Configuration.INamedValue.ValueInstantiationType">
            <summary>
                Normally for injectedObject element this value is <see cref="F:IoC.Configuration.ValueInstantiationType.ResolveFromDiContext" />, for
                other elements (i.e., int16, int32, etc), the overridden value will be <see cref="F:IoC.Configuration.ValueInstantiationType.DeserializeFromStringValue" />
            </summary>
        </member>
        <member name="P:IoC.Configuration.INamedValue.ValueType">
            <summary>
                Can be null only if the parameter is declared with either 'object' or injectedObject elements, and the object type
                referenced is in a disabled assembly.
            </summary>
        </member>
        <member name="T:IoC.Configuration.IoCServiceFactory">
            <summary>
            A service factory.
            </summary>
        </member>
        <member name="M:IoC.Configuration.IoCServiceFactory.CreateAssemblyLocator(System.Func{IoC.Configuration.ConfigurationFile.IConfiguration},System.String)">
            <summary>
            Creates an instance of <see cref="T:IoC.Configuration.IAssemblyLocator" />.
            </summary>
            <param name="getConfugurationFunc">A <see cref="T:System.Func`1" /> objects that returns an instance of
            <see cref="T:IoC.Configuration.ConfigurationFile.IConfiguration" /></param>
            <param name="entryAssemblyFolder"></param>
            <returns></returns>
        </member>
        <member name="M:IoC.Configuration.IoCServiceFactory.CreateTypesListFactoryTypeGenerator(OROptimizer.Serializer.ITypeBasedSimpleSerializerAggregator)">
            <summary>
            Creates an instance of <see cref="T:IoC.Configuration.DynamicCode.ITypesListFactoryTypeGenerator" />
            </summary>
            <param name="typeBasedSimpleSerializerAggregator"></param>
            <returns></returns>
        </member>
        <member name="M:IoC.Configuration.IoCServiceFactory.GetProhibitedServiceTypesInServicesElementChecker">
            <summary>
            Returns instance of <see cref="T:IoC.Configuration.ConfigurationFile.IProhibitedServiceTypesInServicesElementChecker" />.
            </summary>
            <returns></returns>
        </member>
        <member name="T:IoC.Configuration.IoCServiceFactoryAmbientContext">
            <summary>
            This class is used in code that loads the configuration. To provide your own implementation for some of the services used
            replace the value of <see cref="T:IoC.Configuration.IoCServiceFactoryAmbientContext" />.Context with your own implementation of <see cref="T:IoC.Configuration.IIoCServiceFactory" />.
            </summary>
        </member>
        <member name="T:IoC.Configuration.IParameter">
            <summary>
            Represents a parameter value in configuration file. 
            </summary>
            <seealso cref="T:IoC.Configuration.INamedValue" />
        </member>
        <member name="T:IoC.Configuration.IPlugin">
            <summary>
            Represents a plugin object in configuration file.
            </summary>
            <seealso cref="T:IoC.Configuration.ISettingsRequestor" />
            <seealso cref="T:System.IDisposable" />
        </member>
        <member name="M:IoC.Configuration.IPlugin.Initialize">
            <summary>
            Initializes this instance.
            </summary>
        </member>
        <member name="P:IoC.Configuration.IPlugin.PluginData">
            <summary>
                Sets/gets the <see cref="T:IoC.Configuration.IPluginData" /> object corresponding to plugin, retrieved from configuration.
                The implementation should ensure that the plugin data can be set only once, when the configuration is loaded.
                The implementation can subclass from <see cref="T:IoC.Configuration.PluginAbstr" /> to re-use this implementation.
            </summary>
        </member>
        <member name="T:IoC.Configuration.IPluginData">
            <summary>
            Stores plugin related data
            </summary>
        </member>
        <member name="P:IoC.Configuration.IPluginData.Plugin">
            <summary>
            Gets the plugin defined in configuration file.
            </summary>
            <value>
            The plugin.
            </value>
        </member>
        <member name="P:IoC.Configuration.IPluginData.PluginName">
            <summary>
            Gets the name of the plugin.
            </summary>
            <value>
            The name of the plugin.
            </value>
        </member>
        <member name="P:IoC.Configuration.IPluginData.Settings">
            <summary>
            Gets the settings for the plugin that are either specified in element iocConfiguration\pluginsSetup\pluginSetup\settings or
            in element iocConfiguration\settings.
            </summary>
            <value>
            The settings.
            </value>
        </member>
        <member name="T:IoC.Configuration.IPluginDataRepository">
            <summary>
            A repository for data loaded from configuration file for plugins.
            </summary>
        </member>
        <member name="M:IoC.Configuration.IPluginDataRepository.GetPluginData(System.String)">
            <summary>
            Gets the plugin data for plugin with name <paramref name="pluginName"/>.
            </summary>
            <param name="pluginName">Name of the plugin.</param>
            <returns></returns>
        </member>
        <member name="M:IoC.Configuration.IPluginDataRepository.GetPluginData``1">
            <summary>
            Gets the plugin data for the plugin with implementation <typeparamref name="TPluginImplementation"/>. Note, the plugin implementation
            type can be found in element iocConfiguration/pluginsSetup/pluginSetup/pluginImplementation.
            </summary>
            <typeparam name="TPluginImplementation">The type of the plugin implementation.</typeparam>
            <returns></returns>
        </member>
        <member name="M:IoC.Configuration.IPluginDataRepository.GetPluginData(System.Type)">
            <summary>
            Gets the plugin data for the plugin with implementation specified in parameter <paramref name="pluginImplementationType" />.
            Note, the plugin implementation type can be found in element iocConfiguration/pluginsSetup/pluginSetup/pluginImplementation.
            </summary>
            <param name="pluginImplementationType">Type of the plugin implementation.</param>
            <returns></returns>
        </member>
        <member name="P:IoC.Configuration.IPluginDataRepository.Plugins">
            <summary>
            Gets the plugin data objects for all enabled plugins in configuration file.
            </summary>
            <value>
            The plugins.
            </value>
        </member>
        <member name="T:IoC.Configuration.ISetting">
            <summary>
            Represents a setting in configuration file.
            </summary>
            <seealso cref="T:IoC.Configuration.INamedValue" />
        </member>
        <member name="P:IoC.Configuration.ISetting.DeserializedValue">
            <summary>
                The value deserialized from ValueAsString to type in property <see cref="P:IoC.Configuration.INamedValue.ValueType" />
            </summary>
        </member>
        <member name="T:IoC.Configuration.ISettings">
            <summary>
                Settings in element iocCOnfiguration/settings in configuration file.
            </summary>
        </member>
        <member name="P:IoC.Configuration.ISettings.AllSettings">
            <summary>
                A collection of all settings loading from configuration file.
            </summary>
        </member>
        <member name="M:IoC.Configuration.ISettings.GetSetting(System.String)">
            <summary>
                Returns an object of type <see cref="T:IoC.Configuration.ISetting" /> with data loaded from a setting in configuration file.
            </summary>
            <param name="name">Setting name in configuration file.</param>
            <returns>
            Returns an instance of <see cref="T:IoC.Configuration.ISetting"/>, if there is a setting named <paramref name="name"/>.
            Returns null otherwise.
            </returns>
        </member>
        <member name="M:IoC.Configuration.ISettings.GetSettingValue``1(System.String,``0,``0@)">
            <summary>
                Gets the value of a setting, if the setting is present in configuration file and has the specified type.
                Otherwise, returns the specified default value.
            </summary>
            <typeparam name="T">Setting type in configuration file.</typeparam>
            <param name="name">Setting name in configuration file.</param>
            <param name="defaultValue">
                A value to return, if the setting is not in configuration file, or if it is not of
                type <typeparamref name="T" />.
            </param>
            <param name="value">Setting value.</param>
            <returns>
                Returns true, if setting of type <typeparamref name="T" /> is present in configuration file. Returns false
                otherwise.
            </returns>
        </member>
        <member name="M:IoC.Configuration.ISettings.GetSettingValueOrThrow``1(System.String)">
            <summary>
                Gets the value of a setting if the setting is present in configuration file and has the specified type.
                Otherwise, throws an exception.
            </summary>
            <typeparam name="T">Setting type in configuration file.</typeparam>
            <param name="name">Setting name in configuration file</param>
            <returns>Returns setting value.</returns>
            <exception cref="T:System.Exception">Throws this exception.</exception>
        </member>
        <member name="T:IoC.Configuration.ISettingsRequestor">
            <summary>
            Specifies collection of settings, that should be present in configuration file.
            </summary>
        </member>
        <member name="P:IoC.Configuration.ISettingsRequestor.RequiredSettings">
            <summary>
            Gets the collection of settings, that should be present in configuration file.
            </summary>
            <value>
            The required settings.
            </value>
        </member>
        <member name="M:IoC.Configuration.MessagesHelper.GetMultipleImplementationsWithRegisterIfNotRegisteredOptionMessage(System.String)">
            <summary>
                Returns a string: The value of <paramref name="registerIfNotRegisteredSubjectName" /> can be true only if there is
                a single implementation for the service.
            </summary>
            <param name="registerIfNotRegisteredSubjectName"></param>
        </member>
        <member name="T:IoC.Configuration.OnApplicationStart.IOnApplicationsStarted">
            <summary>
                Implement this class to configure application, such as executing custom code on application start.
            </summary>
        </member>
        <member name="T:IoC.Configuration.PluginAbstr">
            <summary>
            Base abstract implementation of <see cref="T:IoC.Configuration.IPlugin"/>.
            Plugin implementation s specified in element iocConfiguration/pluginsSetup/pluginSetup/pluginImplementation can use this class
            as a parent class to use re-use some implementations of <see cref="T:IoC.Configuration.IPlugin"/>. 
            </summary>
            <seealso cref="T:IoC.Configuration.IPlugin" />
        </member>
        <member name="P:IoC.Configuration.PluginAbstr.PluginData">
            <summary>
            Sets/gets the <see cref="T:IoC.Configuration.IPluginData" /> object corresponding to plugin, retrieved from configuration.
            The implementation should ensure that the plugin data can be set only once, when the configuration is loaded.
            The implementation can subclass from <see cref="T:IoC.Configuration.PluginAbstr" /> to re-use this implementation.
            </summary>
        </member>
        <member name="M:IoC.Configuration.PluginAbstr.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
        </member>
        <member name="M:IoC.Configuration.PluginAbstr.Initialize">
            <summary>
            Initializes this instance.
            </summary>
        </member>
        <member name="P:IoC.Configuration.PluginAbstr.RequiredSettings">
            <summary>
            Gets the collection of settings, that should be present in configuration file in element
            iocConfiguration/pluginsSetup/pluginSetup/settings.
            </summary>
            <value>
            The required settings.
            </value>
        </member>
        <member name="T:IoC.Configuration.PluginData">
            <summary>
            Stores plugin related data
            </summary>
        </member>
        <member name="M:IoC.Configuration.PluginData.#ctor(IoC.Configuration.ConfigurationFile.IPluginSetup,IoC.Configuration.IPlugin,IoC.Configuration.ISettings,OROptimizer.Serializer.ITypeBasedSimpleSerializerAggregator)">
            <summary>
            Initializes a new instance of the <see cref="T:IoC.Configuration.PluginData"/> class.
            </summary>
        </member>
        <member name="P:IoC.Configuration.PluginData.Plugin">
            <summary>
             Gets the plugin defined in configuration file.
            </summary>
            <value>
            The plugin.
            </value>
        </member>
        <member name="P:IoC.Configuration.PluginData.PluginName">
            <summary>
            Gets the name of the plugin.
            </summary>
            <value>
            The name of the plugin.
            </value>
        </member>
        <member name="P:IoC.Configuration.PluginData.Settings">
            <summary>
            Gets the settings for the plugin that are either specified in element iocConfiguration\pluginsSetup\pluginSetup\settings or
            in element iocConfiguration\settings.
            </summary>
            <value>
            The settings.
            </value>
        </member>
        <member name="T:IoC.Configuration.PluginDataRepository">
            <summary>
            A repository for data loaded from configuration file for plugins.
            </summary>
        </member>
        <member name="M:IoC.Configuration.PluginDataRepository.#ctor(IoC.Configuration.ConfigurationFile.IPluginsSetup,System.Collections.Generic.IEnumerable{IoC.Configuration.IPlugin},IoC.Configuration.ISettings,OROptimizer.Serializer.ITypeBasedSimpleSerializerAggregator)">
            <summary>
            Initializes a new instance of the <see cref="T:IoC.Configuration.PluginDataRepository"/> class.
            </summary>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:IoC.Configuration.PluginDataRepository.GetPluginData(System.String)">
            <summary>
            Gets the plugin data for plugin with name <paramref name="pluginName" />.
            </summary>
            <param name="pluginName">Name of the plugin.</param>
            <returns></returns>
        </member>
        <member name="M:IoC.Configuration.PluginDataRepository.GetPluginData``1">
            <summary>
            Gets the plugin data for the plugin with implementation <typeparamref name="TPluginImplementation" />. Note, the plugin implementation
            type can be found in element iocConfiguration/pluginsSetup/pluginSetup/pluginImplementation.
            </summary>
            <typeparam name="TPluginImplementation">The type of the plugin implementation.</typeparam>
            <returns></returns>
        </member>
        <member name="M:IoC.Configuration.PluginDataRepository.GetPluginData(System.Type)">
            <summary>
            Gets the plugin data for the plugin with implementation specified in parameter <paramref name="pluginImplementationType" />.
            Note, the plugin implementation type can be found in element iocConfiguration/pluginsSetup/pluginSetup/pluginImplementation.
            </summary>
            <param name="pluginImplementationType">Type of the plugin implementation.</param>
            <returns></returns>
        </member>
        <member name="P:IoC.Configuration.PluginDataRepository.Plugins">
            <summary>
            Gets the plugin data objects for all enabled plugins in configuration file.
            </summary>
            <value>
            The plugins.
            </value>
        </member>
        <member name="T:IoC.Configuration.PluginSettings">
            <summary>
            Stored plugin settings loaded from element iocConfiguration/pluginsSetup/pluginSetup/settings in configuration file.
            </summary>
            <seealso cref="T:IoC.Configuration.ISettings" />
        </member>
        <member name="M:IoC.Configuration.PluginSettings.#ctor(IoC.Configuration.ISettings,IoC.Configuration.ConfigurationFile.ISettingsElement,OROptimizer.Serializer.ITypeBasedSimpleSerializerAggregator)">
            <summary>
            Initializes a new instance of the <see cref="T:IoC.Configuration.PluginSettings"/> class.
            </summary>
        </member>
        <member name="P:IoC.Configuration.PluginSettings.AllSettings">
            <summary>
            A collection of all settings loading from configuration file for the plugin, as well as settings from general settings element,
            that are not in element iocConfiguration/pluginsSetup/pluginSetup/settings.
            </summary>
        </member>
        <member name="M:IoC.Configuration.PluginSettings.GetSetting(System.String)">
            <summary>
            Returns an object of type <see cref="T:IoC.Configuration.ISetting" /> with data loaded from a setting in configuration file.
            Note, if the setting is not in plugin section for the plugin, the setting will be looked up
            in global settings in iocConfiguration/settings as well.
            </summary>
            <param name="name">Setting name in configuration file.</param>
            <returns>
            Returns an instance of <see cref="T:IoC.Configuration.ISetting"/>, if there is a setting named <paramref name="name"/>.
            Returns null otherwise.
            </returns>
        </member>
        <member name="M:IoC.Configuration.PluginSettings.GetSettingValue``1(System.String,``0,``0@)">
            <summary>
            Gets the value of a setting, if the setting is present in configuration file and has the specified type.
            Otherwise, returns the specified default value.
            Note, if the setting is not in plugin section for the plugin, the setting will be looked up
            in global settings in iocConfiguration/settings as well.
            </summary>
            <typeparam name="T">Setting type in configuration file.</typeparam>
            <param name="name">Setting name in configuration file.</param>
            <param name="defaultValue">A value to return, if the setting is not in configuration file, or if it is not of
            type <typeparamref name="T" />.</param>
            <param name="value">Setting value.</param>
            <returns>
            Returns true, if setting of type <typeparamref name="T" /> is present in configuration file. Returns false
            otherwise.
            </returns>
        </member>
        <member name="M:IoC.Configuration.PluginSettings.GetSettingValueOrThrow``1(System.String)">
            <summary>
            Gets the value of a setting if the setting is present in configuration file and has the specified type.
            Otherwise, throws an exception.
            Note, if the setting is not in plugin section for the plugin, the setting will be looked up
            in global settings in iocConfiguration/settings as well.
            </summary>
            <typeparam name="T">Setting type in configuration file.</typeparam>
            <param name="name">Setting name in configuration file</param>
            <returns>
            Returns setting value.
            </returns>
        </member>
        <member name="T:IoC.Configuration.Properties.Resources">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:IoC.Configuration.Properties.Resources.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:IoC.Configuration.Properties.Resources.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:IoC.Configuration.Properties.Resources.IoC_Configuration_Schema_2F7CE7FF_CB22_40B0_9691_EAC689C03A36">
             <summary>
               Looks up a localized string similar to &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
            &lt;xs:schema attributeFormDefault=&quot;unqualified&quot; elementFormDefault=&quot;qualified&quot; xmlns:xs=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;
                &lt;xs:simpleType name=&quot;scopeValues&quot;&gt;
                    &lt;xs:restriction base=&quot;xs:string&quot;&gt;
                        &lt;!--The same object will be used for all service resolutions --&gt;
                        &lt;xs:enumeration value=&quot;singleton&quot;/&gt;
            
                        &lt;!--New object will be created per request--&gt;
                        &lt;xs:enumeration value=&quot;transient&quot;/&gt;
            
                        &lt;!--The same ob [rest of string was truncated]&quot;;.
             </summary>
        </member>
        <member name="P:IoC.Configuration.Properties.Resources.IoC_Configuration_Schema_2F7CE7FF_CB22_40B0_9691_EAC689C03A361">
             <summary>
               Looks up a localized string similar to &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
            &lt;xs:schema attributeFormDefault=&quot;unqualified&quot; elementFormDefault=&quot;qualified&quot; xmlns:xs=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;
                &lt;xs:simpleType name=&quot;scopeValues&quot;&gt;
                    &lt;xs:restriction base=&quot;xs:string&quot;&gt;
                        &lt;!--The same object will be used for all service resolutions --&gt;
                        &lt;xs:enumeration value=&quot;singleton&quot;/&gt;
            
                        &lt;!--New object will be created per request--&gt;
                        &lt;xs:enumeration value=&quot;transient&quot;/&gt;
            
                        &lt;!--The same ob [rest of string was truncated]&quot;;.
             </summary>
        </member>
        <member name="P:IoC.Configuration.Properties.Resources.IoC_Configuration_Schema_2F7CE7FF_CB22_40B0_9691_EAC689C03A362">
             <summary>
               Looks up a localized string similar to &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
            &lt;xs:schema attributeFormDefault=&quot;unqualified&quot; elementFormDefault=&quot;qualified&quot; xmlns:xs=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;
                &lt;xs:simpleType name=&quot;scopeValues&quot;&gt;
                    &lt;xs:restriction base=&quot;xs:string&quot;&gt;
                        &lt;!--The same object will be used for all service resolutions --&gt;
                        &lt;xs:enumeration value=&quot;singleton&quot;/&gt;
            
                        &lt;!--New object will be created per request--&gt;
                        &lt;xs:enumeration value=&quot;transient&quot;/&gt;
            
                        &lt;!--The same ob [rest of string was truncated]&quot;;.
             </summary>
        </member>
        <member name="P:IoC.Configuration.Properties.Resources.IoC_Configuration_Schema_2F7CE7FF_CB22_40B0_9691_EAC689C03A363">
             <summary>
               Looks up a localized string similar to &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
            &lt;xs:schema attributeFormDefault=&quot;unqualified&quot; elementFormDefault=&quot;qualified&quot; xmlns:xs=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;
                &lt;xs:simpleType name=&quot;scopeValues&quot;&gt;
                    &lt;xs:restriction base=&quot;xs:string&quot;&gt;
                        &lt;!--The same object will be used for all service resolutions --&gt;
                        &lt;xs:enumeration value=&quot;singleton&quot;/&gt;
            
                        &lt;!--New object will be created per request--&gt;
                        &lt;xs:enumeration value=&quot;transient&quot;/&gt;
            
                        &lt;!--The same ob [rest of string was truncated]&quot;;.
             </summary>
        </member>
        <member name="T:IoC.Configuration.Setting">
            <summary>
             Represents a setting in configuration file.
            </summary>
            <seealso cref="T:IoC.Configuration.DiContainer.BindingsForConfigFile.NamedValue" />
            <seealso cref="T:IoC.Configuration.ISetting" />
        </member>
        <member name="M:IoC.Configuration.Setting.#ctor(IoC.Configuration.ConfigurationFile.ISettingElement)">
            <summary>
            Initializes a new instance of the <see cref="T:IoC.Configuration.Setting"/> class.
            </summary>
        </member>
        <member name="P:IoC.Configuration.Setting.DeserializedValue">
            <summary>
            The value deserialized from ValueAsString to type in property <see cref="P:IoC.Configuration.INamedValue.ValueType" />
            </summary>
        </member>
        <member name="T:IoC.Configuration.SettingInfo">
            <summary>
            Setting metadata for a setting in configuration file.
            </summary>
        </member>
        <member name="P:IoC.Configuration.SettingInfo.Name">
            <summary>
            Gets the setting name.
            </summary>
            <value>
            The setting name.
            </value>
        </member>
        <member name="P:IoC.Configuration.SettingInfo.ValueDataType">
            <summary>
            Gets the type of the value data.
            </summary>
            <value>
            The type of the value data.
            </value>
        </member>
        <member name="T:IoC.Configuration.Settings">
            <summary>
                Settings in element iocCOnfiguration/settings in configuration file.
            </summary>
        </member>
        <member name="M:IoC.Configuration.Settings.#ctor(IoC.Configuration.ConfigurationFile.ISettingsElement,OROptimizer.Serializer.ITypeBasedSimpleSerializerAggregator)">
            <summary>
            Initializes a new instance of the <see cref="T:IoC.Configuration.Settings"/> class.
            </summary>
        </member>
        <member name="P:IoC.Configuration.Settings.AllSettings">
            <summary>
            A collection of all settings loading from configuration file.
            </summary>
        </member>
        <member name="M:IoC.Configuration.Settings.GetSetting(System.String)">
            <summary>
            Returns an object of type <see cref="T:IoC.Configuration.ISetting" /> with data loaded from a setting in configuration file.
            </summary>
            <param name="name">Setting name in configuration file.</param>
            <returns>
            Returns an instance of <see cref="T:IoC.Configuration.ISetting"/>, if there is a setting named <paramref name="name"/>.
            Returns null otherwise.
            </returns>
        </member>
        <member name="M:IoC.Configuration.Settings.GetSettingValue``1(System.String,``0,``0@)">
            <summary>
            Gets the value of a setting, if the setting is present in configuration file and has the specified type.
            Otherwise, returns the specified default value.
            </summary>
            <typeparam name="T">Setting type in configuration file.</typeparam>
            <param name="name">Setting name in configuration file.</param>
            <param name="defaultValue">A value to return, if the setting is not in configuration file, or if it is not of
            type <typeparamref name="T" />.</param>
            <param name="value">Setting value.</param>
            <returns>
            Returns true, if setting of type <typeparamref name="T" /> is present in configuration file. Returns false
            otherwise.
            </returns>
        </member>
        <member name="M:IoC.Configuration.Settings.GetSettingValueOrThrow``1(System.String)">
            <summary>
            Gets the value of a setting if the setting is present in configuration file and has the specified type.
            Otherwise, throws an exception.
            </summary>
            <typeparam name="T">Setting type in configuration file.</typeparam>
            <param name="name">Setting name in configuration file</param>
            <returns>
            Returns setting value.
            </returns>
        </member>
        <member name="T:IoC.Configuration.SettingsRequestorDefault">
            <summary>
            Default implementation of <see cref="T:IoC.Configuration.ISettingsRequestor"/> that does not enforce any required settings in configuration file.
            Specify your own implementation in element iocConfiguration/settingsRequestor to change the default behaviour.
            </summary>
            <seealso cref="T:IoC.Configuration.ISettingsRequestor" />
        </member>
        <member name="P:IoC.Configuration.SettingsRequestorDefault.RequiredSettings">
            <summary>
            Gets the collection of settings, that should be present in configuration file.
            </summary>
            <value>
            The required settings.
            </value>
        </member>
    </members>
</doc>
