<?xml version="1.0"?>
<doc>
    <assembly>
        <name>IoC.Configuration</name>
    </assembly>
    <members>
        <member name="T:IoC.Configuration.ConfigurationFileXmlDocumentLoadedEventArgs">
            <summary>
                Event arguments for the configuration XmlDocument.
            </summary>
        </member>
        <member name="M:IoC.Configuration.ConfigurationFileXmlDocumentLoadedEventArgs.#ctor(System.Xml.XmlDocument)">
            <summary>
                A constructor.
            </summary>
            <param name="xmlDocument"></param>
        </member>
        <member name="P:IoC.Configuration.ConfigurationFileXmlDocumentLoadedEventArgs.XmlDocument">
            <summary>
                Event arguments for the configuration XmlDocument.
                Note, the XmlDocument is not yet validated agains schema. Therefore, if the XmlDocument is modified,
                it should be modified in such a way, that it still confirms to schema.
            </summary>
        </member>
        <member name="M:IoC.Configuration.ConfigurationFile.Helpers.ConvertTo``1(IoC.Configuration.ConfigurationFile.IConfigurationFileElement)">
            <summary>
                Converts <paramref name="configurationFileElement" /> to type <typeparamref name="T" />. Throws an exception if the
                conversion fails.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="configurationFileElement"></param>
            <returns>Converted value.</returns>
            <exception cref="T:IoC.Configuration.ConfigurationFile.ConfigurationParseException">Throws this exception.</exception>
        </member>
        <member name="M:IoC.Configuration.ConfigurationFile.Helpers.GetAssemblySettingByAssemblyAlias(IoC.Configuration.ConfigurationFile.IConfigurationFileElement,System.String)">
            <summary>
            </summary>
            <param name="requestorFileElement"></param>
            <param name="assemblyAlias"></param>
            <returns></returns>
            <exception cref="T:IoC.Configuration.ConfigurationFile.ConfigurationParseException">
                Throws this exception if the assembly with specified alias
                does not exitst in configuration file.
            </exception>
        </member>
        <member name="M:IoC.Configuration.ConfigurationFile.Helpers.GetAttributeValue``1(IoC.Configuration.ConfigurationFile.IConfigurationFileElement,System.String)">
            <summary>
            </summary>
            <typeparam name="T"></typeparam>
            <param name="configurationFileElement"></param>
            <param name="attributeName"></param>
            <returns></returns>
            <exception cref="T:IoC.Configuration.ConfigurationFile.ConfigurationParseException">
                Throws this exception if the attribute value cannot be converted to type
                of 'T'.
            </exception>
        </member>
        <member name="M:IoC.Configuration.ConfigurationFile.Helpers.GetEnabledAttributeValue(IoC.Configuration.ConfigurationFile.IConfigurationFileElement)">
            <summary>
            </summary>
            <param name="configurationFileElement"></param>
            <exception cref="T:IoC.Configuration.ConfigurationFile.ConfigurationParseException">
                Throws this exception if the attribute value cannot be conveted to a
                boolean value.
            </exception>
        </member>
        <member name="M:IoC.Configuration.ConfigurationFile.Helpers.GetNameAttributeValue(IoC.Configuration.ConfigurationFile.IConfigurationFileElement)">
            <summary>
            </summary>
            <param name="configurationFileElement"></param>
            <exception cref="T:IoC.Configuration.ConfigurationFile.ConfigurationParseException">Throws this exception if the attribute value is null or empty string.</exception>
        </member>
        <member name="M:IoC.Configuration.ConfigurationFile.Helpers.GetTypeInAssembly(IoC.Configuration.IAssemblyLocator,IoC.Configuration.ConfigurationFile.IConfigurationFileElement,IoC.Configuration.ConfigurationFile.IAssembly,System.String)">
            <summary>
            </summary>
            <param name="assemblyLocator"></param>
            <param name="requestorFileElement"></param>
            <param name="assemblyElement"></param>
            <param name="typeFullName"></param>
            <returns></returns>
            <exception cref="T:IoC.Configuration.ConfigurationFile.ConfigurationParseException">Throws this exception if the type is not in an assembly.</exception>
        </member>
        <member name="P:IoC.Configuration.ConfigurationFile.IAssembly.AbsolutePath">
            <summary>
                Absolute full path of assembly file.
            </summary>
        </member>
        <member name="M:IoC.Configuration.ConfigurationFile.IConfigurationFileElement.AddChild(IoC.Configuration.ConfigurationFile.IConfigurationFileElement)">
            <summary>
            </summary>
            <param name="child"></param>
            <exception cref="T:IoC.Configuration.ConfigurationFile.ConfigurationParseException"></exception>
        </member>
        <member name="M:IoC.Configuration.ConfigurationFile.IConfigurationFileElement.Initialize">
            <summary>
            </summary>
            <exception cref="T:IoC.Configuration.ConfigurationFile.ConfigurationParseException"></exception>
        </member>
        <member name="P:IoC.Configuration.ConfigurationFile.IConfigurationFileElement.OwningPluginElement">
            <summary>
                If not null, specifies the plugin to which the element is applicable. Otherwise, the element does not belong to any
                plugin.
            </summary>
        </member>
        <member name="M:IoC.Configuration.ConfigurationFile.IConfigurationFileElement.ValidateAfterChildrenAdded">
            <summary>
            </summary>
            <exception cref="T:IoC.Configuration.ConfigurationFile.ConfigurationParseException"></exception>
        </member>
        <member name="M:IoC.Configuration.ConfigurationFile.IConfigurationFileElementFactory.CreateConfigurationFileElement(System.Xml.XmlElement,IoC.Configuration.ConfigurationFile.IConfigurationFileElement)">
            <summary>
            </summary>
            <param name="xmlElement"></param>
            <param name="parentConfigurationFileElement"></param>
            <exception cref="T:System.Exception">Throws an exception if can't create an element.</exception>
            <returns></returns>
            <exception cref="T:IoC.Configuration.ConfigurationFile.ConfigurationParseException"></exception>
        </member>
        <member name="P:IoC.Configuration.ConfigurationFile.IDiManagersElement.ActiveDiManagerElement">
            <summary>
                The value is not null, if the configuration file is successfully loaded.
            </summary>
        </member>
        <member name="P:IoC.Configuration.ConfigurationFile.IModuleElement.DiModule">
            <summary>
                Is null if the module is disabled.
                Has non null value otherwise.
            </summary>
        </member>
        <member name="P:IoC.Configuration.ConfigurationFile.IParameterElement.DeserializedValue">
            <summary>
                The value deserialized from ValueAsString to type in property <see cref="P:IoC.Configuration.INamedValue.ValueType" />
            </summary>
        </member>
        <member name="P:IoC.Configuration.ConfigurationFile.IParameterSerializer.Serializer">
            <summary>
                Can be null only if Enabled is false.
            </summary>
        </member>
        <member name="T:IoC.Configuration.ConfigurationFile.IProhibitedServiceTypesInServicesElementChecker">
            <summary>
                Checks if the given type can be used as a service type under 'services' element in configuration file.
            </summary>
        </member>
        <member name="M:IoC.Configuration.ConfigurationFile.IProhibitedServiceTypesInServicesElementChecker.IsServiceTypeAllowed(System.Type)">
            <summary>
                Checks if <paramref name="serviceType" /> can be used as a service type under
                'services' element in configuration file.
            </summary>
            <param name="serviceType"></param>
            <returns>
                Returns true if <paramref name="serviceType" /> can be used as a service type under
                'services' element in configuration file.
                Returns false otherwise.
            </returns>
        </member>
        <member name="P:IoC.Configuration.ConfigurationFile.ITypeFactory.ImplementedMethodInfo">
            <summary>
                Null only of element is disabled
            </summary>
        </member>
        <member name="P:IoC.Configuration.ConfigurationFile.ITypeFactoryReturnedType.ReturnedType">
            <summary>
                Null only of element is disabled
            </summary>
        </member>
        <member name="M:IoC.Configuration.ConfigurationFile.Services.ThrowOnProhibitedServiceType(IoC.Configuration.ConfigurationFile.IServiceElement,System.String)">
            <summary>
            </summary>
            <param name="serviceElement"></param>
            <param name="serviceImplementatipnLocation"></param>
            <exception cref="T:IoC.Configuration.ConfigurationFile.ConfigurationParseException">Always throws this exception.</exception>
        </member>
        <member name="M:IoC.Configuration.DiContainerBuilder.CodeBased.CodeBasedConfiguration.#ctor(IoC.Configuration.DiContainer.IDiManager,System.String,System.String[])">
            <summary>
            </summary>
            <param name="diManager"></param>
            <param name="entryAssemblyFolder">
                The location where the executable is.
                For non test projects <see cref="P:OROptimizer.IGlobalsCore.EntryAssemblyFolder" /> can be used as a value for this parameter.
                However, for tests projects <see cref="P:OROptimizer.IGlobalsCore.EntryAssemblyFolder" /> might be
                be the folder where the test execution library is, so a different value might need to be passed.
            </param>
            <param name="assemblyProbingPaths"></param>
        </member>
        <member name="M:IoC.Configuration.DiContainerBuilder.CodeBased.CodeBasedConfiguration.#ctor(System.String,System.String,OROptimizer.ParameterInfo[],System.String,System.String[])">
            <summary>
            </summary>
            <param name="diManagerClassFullName"></param>
            <param name="diManagerClassAssemblyFilePath"></param>
            <param name="diManagerConstructorParameters"></param>
            <param name="entryAssemblyFolder">
                The location where the executable is.
                For non test projects <see cref="P:OROptimizer.IGlobalsCore.EntryAssemblyFolder" /> can be used as a value for this parameter.
                However, for tests projects <see cref="P:OROptimizer.IGlobalsCore.EntryAssemblyFolder" /> might be
                be the folder where the test execution library is, so a different value might need to be passed.
            </param>
            <param name="assemblyProbingPaths"></param>
        </member>
        <member name="M:IoC.Configuration.DiContainerBuilder.CodeBased.CodeBasedConfiguration.DefaultModule.AddServiceRegistrations">
            <summary>
                Use OnlyIfNotRegistered with all binding configurations, to use custom binding that the user might have specified
                in configuration
                file or in modules.
            </summary>
        </member>
        <member name="M:IoC.Configuration.DiContainerBuilder.CodeBased.ICodeBasedDiContainerConfigurator.WithoutPresetDiContainer">
            <summary>
                The container will be automatically created. This is the preferred way to build a container.
                Use <see cref="M:IoC.Configuration.DiContainerBuilder.CodeBased.ICodeBasedDiContainerConfigurator.WithDiContainer(IoC.Configuration.DiContainer.IDiContainer)" /> only if the application already has a container, and we need to use it.
            </summary>
            <returns></returns>
        </member>
        <member name="M:IoC.Configuration.DiContainerBuilder.CodeBased.ICodeBasedDiModulesConfigurator.AddNativeModules(System.Object[])">
            <summary>
                Add native modules, such as Autofac or Ninject modules.
            </summary>
            <param name="nativeModules"></param>
        </member>
        <member name="M:IoC.Configuration.DiContainerBuilder.DiContainerBuilder.StartCodeBasedDi(System.String,System.String,OROptimizer.ParameterInfo[],System.String,System.String[])">
            <summary>
            </summary>
            <param name="diManagerClassFullName">Should be full a full name of a class that implements <see cref="T:IoC.Configuration.DiContainer.IDiManager" />.</param>
            <param name="diManagerClassAssemblyFilePath">
                Full path of assembly, containing the class specified parameter
                <paramref name="diManagerClassFullName" />.
            </param>
            <param name="diManagerConstructorParameters">
                Collection of constructor parameter type/value combinations to be passed to a constructor in class specified
                in parameter <paramref name="diManagerClassFullName" />.
            </param>
            <param name="entryAssemblyFolder"></param>
            <param name="assemblyProbingPaths">Additional assembly probing paths.</param>
        </member>
        <member name="M:IoC.Configuration.DiContainerBuilder.DiContainerBuilderConfiguration.#ctor(System.String)">
            <summary>
                A constructor.
            </summary>
            <param name="entryAssemblyFolder">
                The location where the executable is.
                For non test projects <see cref="P:OROptimizer.IGlobalsCore.EntryAssemblyFolder" /> can be used as a value for this parameter.
                However, for tests projects <see cref="P:OROptimizer.IGlobalsCore.EntryAssemblyFolder" /> might be
                be the folder where the test execution library is, so a different value might need to be passed.
            </param>
        </member>
        <member name="M:IoC.Configuration.DiContainerBuilder.DiContainerBuilderConfiguration.Init">
            <summary>
                Override this to do initialization. This method should be called after the object is constructed.
            </summary>
        </member>
        <member name="P:IoC.Configuration.DiContainerBuilder.DiContainerBuilderConfiguration.NativeAndDiModules">
            <summary>
                List of native module objects (such as Autofac or Ninject modules), as well as <see cref="T:IoC.Configuration.DiContainer.IDiModule" /> objects
            </summary>
        </member>
        <member name="M:IoC.Configuration.DiContainerBuilder.FileBased.FileBasedConfiguration.#ctor(IoC.Configuration.IConfigurationFileContentsProvider,System.String,IoC.Configuration.ConfigurationFileXmlDocumentLoadedEventHandler)">
            <summary>
            </summary>
            <param name="configurationFileContentsProvider"></param>
            <param name="entryAssemblyFolder">
                The location where the executable is.
                For non test projects <see cref="P:OROptimizer.IGlobalsCore.EntryAssemblyFolder" /> can be used as a value for this parameter.
                However, for tests projects <see cref="P:OROptimizer.IGlobalsCore.EntryAssemblyFolder" /> might be
                be the folder where the test execution library is, so a different value might need to be passed.
            </param>
            <param name="configurationFileXmlDocumentLoaded"></param>
        </member>
        <member name="M:IoC.Configuration.DiContainerBuilder.FileBased.FileBasedConfiguration.DefaultModule.AddServiceRegistrations">
            <summary>
                Use OnlyIfNotRegistered with all binding configurations, to use custom binding that the user might have specified
                in configuration
                file or in modules.
            </summary>
        </member>
        <member name="T:IoC.Configuration.DiContainerBuilder.FileBased.FileBasedConfiguration.ModuleInfo">
            <summary>
                This class stores details about native and non-native modules, and initializes the modules at a later time,
                when dynamic assembly is created.
            </summary>
        </member>
        <member name="M:IoC.Configuration.DiContainerBuilder.FileBased.FileBasedConfiguration.ModuleInfo.#ctor(IoC.Configuration.DiContainerBuilder.FileBased.FileBasedConfiguration,IoC.Configuration.DiContainer.BindingsForCode.IServiceRegistrationBuilder,System.Object)">
            <summary>
                Use this constructor for either native modules (e.g., Autofac or Ninject module), or modules of type
                <see cref="T:IoC.Configuration.DiContainer.IDiModule" />.
            </summary>
        </member>
        <member name="M:IoC.Configuration.DiContainerBuilder.FileBased.FileBasedConfiguration.ModuleInfo.#ctor(IoC.Configuration.DiContainerBuilder.FileBased.FileBasedConfiguration,System.String)">
            <summary>
                This constructor specifies a class full name for a native module.
            </summary>
            <param name="fileBasedConfiguration"></param>
            <param name="moduleClassFullName"></param>
        </member>
        <member name="M:IoC.Configuration.DiContainerBuilder.FileBased.IFileBasedDiContainerConfigurator.WithoutPresetDiContainer">
            <summary>
                The container will be automatically created. This is the preferred way to build a container.
                Use <see cref="M:IoC.Configuration.DiContainerBuilder.FileBased.IFileBasedDiContainerConfigurator.WithDiContainer(IoC.Configuration.DiContainer.IDiContainer)" /> only if the application already has a container, and we need to use it.
            </summary>
            <returns></returns>
        </member>
        <member name="M:IoC.Configuration.DiContainerBuilder.FileBased.IFileBasedDiModulesConfigurator.AddNativeModules(System.Object[])">
            <summary>
                Add native modules, such as Autofac or Ninject modules.
            </summary>
            <param name="nativeModules"></param>
            <returns></returns>
        </member>
        <member name="M:IoC.Configuration.DiContainer.BindingConfiguration`1.ValidateBeforeImplementationsValidated">
            <summary>
                Override this to do more validation, before implementations are validated
            </summary>
        </member>
        <member name="M:IoC.Configuration.DiContainer.BindingConfiguration`1.Validate">
            <summary>
            </summary>
            <exception cref="T:System.Exception">Throws an exception if service binding data is invalid.</exception>
        </member>
        <member name="P:IoC.Configuration.DiContainer.BindingImplementationConfiguration.ResolutionScope">
            <summary>
                If not set, will default to <see cref="F:IoC.Configuration.DiContainer.DiResolutionScope.Singleton" />.
            </summary>
        </member>
        <member name="M:IoC.Configuration.DiContainer.BindingImplementationConfiguration.Validate">
            <summary>
            </summary>
            <exception cref="T:System.Exception">
                Throws an exception if service binding data is invalid. Example of invalid data is invalid
                implementation type.
            </exception>
        </member>
        <member name="P:IoC.Configuration.DiContainer.BindingsForCode.BindingImplementationConfigurationForCode.OnImplementationObjectActivated">
            <summary>
                Will be called after the implementation object is activated.
                Use this for property injection.
                The value of <see cref="T:System.Object" /> parameter is the activated implementation instance.
            </summary>
        </member>
        <member name="M:IoC.Configuration.DiContainer.BindingsForCode.IBindingGeneric`1.To``1(System.Func{IoC.Configuration.DiContainer.IDiContainer,``0})">
            <summary>
                TImplementation should be either <typeparamref name="TService" />, or a type that implements or derives from
                <typeparamref name="TService" />.
                Note, normally we can use value of TService for TImplementation not to restrict what the function
                <paramref name="resolverFunc" /> returns, as long as it returns <typeparamref name="TService" /> object.
            </summary>
            <typeparam name="TImplementation"></typeparam>
            <param name="resolverFunc"></param>
            <returns></returns>
        </member>
        <member name="P:IoC.Configuration.DiContainer.BindingsForCode.IBindingImplementationGeneric`2.Service">
            <summary>
                Use this member to add multiple implementations for the same service.
            </summary>
        </member>
        <member name="P:IoC.Configuration.DiContainer.BindingsForCode.IBindingImplementationNonGeneric.Service">
            <summary>
                Use this member to add multiple implementations for the same service.
            </summary>
        </member>
        <member name="P:IoC.Configuration.DiContainer.BindingsForConfigFile.BindingImplementationConfigurationForFile.Parameters">
            <summary>
                If the value is null, the parameters will be injected.
                Otherwise, a constructor which matches the parameters by type and name will
                be used to create an implementation.
            </summary>
        </member>
        <member name="M:IoC.Configuration.DiContainer.DiManagerImplementationHelper.ThrowUnsupportedFeature(IoC.Configuration.DiContainer.NonStandardFeatures,IoC.Configuration.DiContainer.IDiManager)">
            <summary>
                Throws n exception, if the feature specified in parameter <paramref name="nonStandardFeatures" /> is not supported
                by container implementation specified in parameter <paramref name="diManager" />.
            </summary>
            <param name="nonStandardFeatures"></param>
            <param name="diManager"></param>
            <exception cref="T:System.Exception">Always throws this exception.</exception>
        </member>
        <member name="M:IoC.Configuration.DiContainer.DiManagerImplementationHelper.ThrowUnsupportedResolutionScope(IoC.Configuration.DiContainer.BindingsForConfigFile.BindingImplementationConfigurationForFile)">
            <summary>
                Throw an exception, if the value of <see cref="P:IoC.Configuration.ConfigurationFile.IServiceImplementationElement.ResolutionScope" /> is unsupported by
                the implementation of <see cref="T:IoC.Configuration.DiContainer.IDiManager" />.
            </summary>
            <param name="serviceImplementationElement"></param>
            <exception cref="T:System.Exception">Always throws this exception.</exception>
        </member>
        <member name="M:IoC.Configuration.DiContainer.IDiContainer.Resolve``1">
            <summary>
                Resolved the type using the life time scope <see cref="P:IoC.Configuration.DiContainer.IDiContainer.CurrentLifeTimeScope" />.
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:IoC.Configuration.DiContainer.IDiContainer.Resolve(System.Type)">
            <summary>
                Resolved the type using the life time scope <see cref="P:IoC.Configuration.DiContainer.IDiContainer.CurrentLifeTimeScope" />.
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:IoC.Configuration.DiContainer.IDiContainer.Resolve``1(IoC.Configuration.DiContainer.ILifeTimeScope)">
            <summary>
                Sets the value of <see cref="P:IoC.Configuration.DiContainer.IDiContainer.CurrentLifeTimeScope" /> to the value of parameter
                <paramref name="lifeTimeScope" />,
                resolved the object using<paramref name="lifeTimeScope" />, and restores the value of
                <see cref="P:IoC.Configuration.DiContainer.IDiContainer.CurrentLifeTimeScope" /> to its
                previous value, after the type resolution is complete.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="lifeTimeScope"></param>
            <returns></returns>
        </member>
        <member name="M:IoC.Configuration.DiContainer.IDiContainer.Resolve(System.Type,IoC.Configuration.DiContainer.ILifeTimeScope)">
            <summary>
                Sets the value of <see cref="P:IoC.Configuration.DiContainer.IDiContainer.CurrentLifeTimeScope" /> to the value of parameter <paramref name="lifeTimeScope" />,
                resolved the object using <paramref name="lifeTimeScope" />, and restores the value of
                <see cref="P:IoC.Configuration.DiContainer.IDiContainer.CurrentLifeTimeScope" /> to its
                previous value, after the type resolution is complete.
            </summary>
            <param name="type"></param>
            <param name="lifeTimeScope"></param>
            <returns></returns>
        </member>
        <member name="M:IoC.Configuration.DiContainer.IDiContainer.StartMainLifeTimeScope">
            <summary>
                Starts a new life time scope and assigns it to <see cref="P:IoC.Configuration.DiContainer.IDiContainer.MainLifeTimeScope" />.
            </summary>
        </member>
        <member name="M:IoC.Configuration.DiContainer.IDiManager.BuildServiceProvider(IoC.Configuration.DiContainer.IDiContainer,System.Collections.Generic.IEnumerable{System.Object})">
            <summary>
                This method registers modules with service provider.
            </summary>
            <param name="diContainer"></param>
            <param name="modules"></param>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:IoC.Configuration.DiContainer.IDiManager.CreateDiContainer">
            <summary>
                Creates a native container object of type <see cref="T:IoC.Configuration.DiContainer.IDiContainer" />. The object can be used to pass as a
                parameter in class constructors,
                however it might not be in a state to be used to resolve services. before services can be resolved, call
                the <see cref="M:IoC.Configuration.DiContainer.IDiManager.BuildServiceProvider(IoC.Configuration.DiContainer.IDiContainer,System.Collections.Generic.IEnumerable{System.Object})" /> method.
            </summary>
            <returns></returns>
        </member>
        <member name="M:IoC.Configuration.DiContainer.IDiManager.GenerateModuleClassCode(OROptimizer.DynamicCode.IDynamicAssemblyBuilder,IoC.Configuration.IAssemblyLocator,System.String,System.String,System.Collections.Generic.IEnumerable{IoC.Configuration.DiContainer.BindingsForConfigFile.BindingConfigurationForFile})">
            <summary>
                Generates a new DI Module with module class name specified in parameter <paramref name="moduleClassName" />
                Adds the generated module C# file using <see cref="M:OROptimizer.DynamicCode.IDynamicAssemblyBuilder.AddCSharpFile(System.String)" /> method.
                The generated class should have a parameterless constructor. If the generated module class has a public
                method <see cref="F:IoC.Configuration.HelpersIoC.OnDiContainerReadyMethodName" />(IoC.Configuration.DiContainer.IDiContainer
                diContainer),
                it will be executed with a parameter <see cref="T:IoC.Configuration.DiContainer.IDiContainer" /> when the container is ready to resolve services.
            </summary>
            <param name="dynamicAssemblyBuilder"></param>
            <param name="assemblyLocator"></param>
            <param name="moduleClassNamespace"></param>
            <param name="moduleClassName"></param>
            <param name="moduleServiceConfigurationElements">Collection of all services to use when building the module</param>
            <exception cref="T:System.Exception">Throw this exception if module fails to get generated.</exception>
            <returns>Returns generated module class code.</returns>
        </member>
        <member name="M:IoC.Configuration.DiContainer.IDiManager.GenerateNativeModule(IoC.Configuration.DiContainer.IDiModule)">
            <summary>
                This class takes an object of type <see cref="T:IoC.Configuration.DiContainer.IDiModule" />  and converts it to
                a module of some DI container, such as Autofac or Ninject.
            </summary>
            <param name="module"></param>
            <returns>Returns a native DI module such an Autofac Module class object.</returns>
        </member>
        <member name="M:IoC.Configuration.DiContainer.IDiManager.GetRequiredBindingsModule">
            <summary>
                Returns a module object, such as Autofac or Ninjectmodule, which sets all the requierd binding.
                For example this module can add binding for <see cref="T:IoC.Configuration.DiContainer.IDiContainer" /> among other things.
            </summary>
            <returns></returns>
        </member>
        <member name="P:IoC.Configuration.DiContainer.IDiManager.ModuleType">
            <summary>
                For example for Autofac based implementation of <see cref="P:IoC.Configuration.DiContainer.IDiManager.ModuleType" /> will return type of Autofac.Module.
            </summary>
        </member>
        <member name="M:IoC.Configuration.DiContainer.IDiManager.StartServiceProvider(IoC.Configuration.DiContainer.IDiContainer)">
            <summary>
                Starts the container. After this method is called,  calls to <see cref="M:IoC.Configuration.DiContainer.IDiContainer.Resolve(System.Type)" /> can be made
                to resolve services.
            </summary>
            <param name="diContainer">Dependency injection container to start.</param>
        </member>
        <member name="T:IoC.Configuration.DiContainer.IDiModule">
            <summary>
                Look at <see cref="T:IoC.Configuration.DiContainer.ModuleAbstr" /> for implementation example for this method.
                Normally, one would subclass from <see cref="T:IoC.Configuration.DiContainer.ModuleAbstr" /> and override the method
                <see cref="M:IoC.Configuration.DiContainer.ModuleAbstr.AddServiceRegistrations" />.
                Within the body of <see cref="M:IoC.Configuration.DiContainer.ModuleAbstr.AddServiceRegistrations" />, one can use statements like:
                Bind &lt;IService1&gt;().OnlyIfNotRegistered().To&lt;Service1&gt;
                ().SetResolutionScope(DiResolutionScope.Singleton);
            </summary>
        </member>
        <member name="M:IoC.Configuration.DiContainer.IDiModule.Load">
            <summary>
                Adds bindings and validates the added bindings.
            </summary>
        </member>
        <member name="T:IoC.Configuration.DiContainer.ModuleAbstr">
            <summary>
                Normally, one would subclass from <see cref="T:IoC.Configuration.DiContainer.ModuleAbstr" /> and override the method
                <see cref="M:IoC.Configuration.DiContainer.ModuleAbstr.AddServiceRegistrations" />.
                Within the body of <see cref="M:IoC.Configuration.DiContainer.ModuleAbstr.AddServiceRegistrations" />, one can use statements like:
                Bind &lt;IService1&gt;().OnlyIfNotRegistered().To&lt;Service1&gt;
                ().SetResolutionScope(DiResolutionScope.Singleton);
            </summary>
        </member>
        <member name="M:IoC.Configuration.DiContainer.ModuleAbstr.AddServiceRegistrations">
            <summary>
                Override this method to register services. The body of overridden method might have statements like:
                Bind &lt;IService1&gt;().OnlyIfNotRegistered().To&lt;Service1&gt;
                ().SetResolutionScope(DiResolutionScope.Singleton);
            </summary>
        </member>
        <member name="F:IoC.Configuration.DiContainer.NonStandardFeatures.RegisterServiceWithSingleImplementationsOnlyIfServiceNotRegistered">
            <summary>
                Allows registering a service, only if the service is not registered, when there is only one implementation for the
                service.
            </summary>
        </member>
        <member name="F:IoC.Configuration.DiContainer.NonStandardFeatures.RegisterServiceWithMultipleImplementationsOnlyIfServiceNotRegistered">
            <summary>
                Allows registering a service, only if the service is not registered, when multiple implementations are registered
                for the service.
                The specific IoC container (e.g., Autofac, Ninject, etc),
                should support registering multiple implementations of the service, if the service was not registered.
                For example Autofac currently supports this for single implementation (using IfNotRegistered(Type)), but there is
                no way to do this for
                multiple implementations of a service (i.e., check if service was registered, and register all implementations if
                it was not).
            </summary>
        </member>
        <member name="F:IoC.Configuration.DiContainer.NonStandardFeatures.WhenInjectedIntoClassOrSubClassesConditionalInjection">
            <summary>
                Specific implementation will be applied only if the implementation is injected into a specific type or its
                subclasses.
            </summary>
        </member>
        <member name="F:IoC.Configuration.DiContainer.NonStandardFeatures.WhenInjectedExactlyIntoClassConditionalInjection">
            <summary>
                Specific implementation will be applied only if the implementation is injected into a specific type.
            </summary>
        </member>
        <member name="F:IoC.Configuration.DiContainer.TargetImplementationType.Self">
            <summary>
                Service is bound to its own type
            </summary>
        </member>
        <member name="F:IoC.Configuration.DiContainer.TargetImplementationType.Type">
            <summary>
                Type of implementation
            </summary>
        </member>
        <member name="F:IoC.Configuration.DiContainer.TargetImplementationType.Delegate">
            <summary>
                A delegate that returns implementation object
            </summary>
        </member>
        <member name="M:IoC.Configuration.DynamicCode.ITypesListFactoryTypeGenerator.GenerateType(OROptimizer.DynamicCode.IDynamicAssemblyBuilder,System.Type,System.String,System.Collections.Generic.IEnumerable{System.Type},System.Collections.Generic.IEnumerable{System.String[]},System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{System.Type}})">
            <summary>
                Generates a C# file for a type that is an implementation of interface specified in
                <paramref name="interfaceToImplement" /> parameter.
                Calls <see cref="M:OROptimizer.DynamicCode.IDynamicAssemblyBuilder.AddCSharpFile(System.String)" /> to add the generated C# file to an assembly being
                built.
                Interface <paramref name="interfaceToImplement" /> should have exactly one method that has arbitrary number
                of parameters, and returns <see cref="T:System.Collections.Generic.IEnumerable`1" />, where T is an interface.
            </summary>
            <param name="dynamicAssemblyBuilder"></param>
            <param name="interfaceToImplement"></param>
            <param name="dynamicImplementationsNamespace">Namespace to use for generated classes.</param>
            <param name="returnedInstanceTypesForDefaultCase"></param>
            <param name="selectorParameterValues"></param>
            <param name="returnedInstanceTypesForSelectorParameterValues"></param>
            <returns>Returns generated type information, such as class full name and C# file contents.</returns>
            <exception cref="T:System.Exception">Throws exception if the implementation generation fails.</exception>
        </member>
        <member name="T:IoC.Configuration.FileBasedConfigurationFileContentsProvider">
            <summary>
                An implementation of IConfigurationFileContentProvider, that loads configuration file contents form a file
            </summary>
        </member>
        <member name="M:IoC.Configuration.FileBasedConfigurationFileContentsProvider.#ctor(System.String)">
            <summary>
                A constructor.
            </summary>
            <param name="configurationFilePath"></param>
        </member>
        <member name="M:IoC.Configuration.IAssemblyLocator.FindAssemblyPath(System.String,System.String,System.Collections.Generic.IList{System.String}@)">
            <summary>
                Looks for assembly in the following folders in the order specified:
                - Assemblies loaded into current AppDomain,
                - assemblies in .Net core default folder (Microsoft assemblies),
                - assemblies in installation folder
                - assemblies specified in element iocConfiguration/additionalAssemblyProbingPaths,
                - assemblies in element iocConfiguration/plugins/plugin for the plugin specified in parameter
                <paramref name="pluginName" />.
            </summary>
            <param name="assemblyName"></param>
            <param name="pluginName">
                If the value is not null, the search will be also done in plugin folder of the specified
                plugin.
            </param>
            <param name="searchedDirectories">Returns the list of searched directories.</param>
            <returns>Returns the full path of the assembly.</returns>
        </member>
        <member name="M:IoC.Configuration.IAssemblyLocator.FindAssemblyPathInAllPluginFolders(System.String,System.String)">
            <summary>
                This method is similar to the other method in this class with three parameters, except it searches for assembly in
                all plugin folders, and does not output
                searched directories.
            </summary>
            <param name="assemblyName"></param>
            <param name="requestingAssemblyFolder">If not null, the requesting assembly folder will be searched as well.</param>
            <returns></returns>
        </member>
        <member name="M:IoC.Configuration.IAssemblyLocator.LoadAssembly(System.String,System.String)">
            <summary>
                Searches for the assembly in .Net directories, installation directories, probing paths and plugin folders. If the
                assembly is found, it is loaded
                into current application domain.
            </summary>
            <param name="assemblyNameWithExtension"></param>
            <param name="assemblyFolder">
                If the value is not null an dis not an empty string, it will be used to generated assembly path to load.
                Otherwise, assembly will be searched in multiple directories bu name.
            </param>
            <returns></returns>
            <exception cref="T:System.Exception">Throws an exception if assembly fails to get loaded.</exception>
        </member>
        <member name="T:IoC.Configuration.IConfigurationFileContentsProvider">
            <summary>
                An interface that provides IoC configuration file content.
            </summary>
        </member>
        <member name="P:IoC.Configuration.IConfigurationFileContentsProvider.ConfigurationFileSourceDetails">
            <summary>
                Some details of the source, where the configuration file contents are loaded from. Examples are: file path or
                database record
                id, that has the configuration.
            </summary>
        </member>
        <member name="M:IoC.Configuration.IConfigurationFileContentsProvider.LoadConfigurationFileContents">
            <summary>
                Returns IoC configuration file content as a string. The content should be a valid XML document and
                should be successfully validated using the schema file IoC.Configuration.Schema.xsd.
            </summary>
            <returns>Returns a <see cref="T:System.IO.Stream" /> object for the configuration file contents.</returns>
            <exception cref="T:System.Exception">Throws an exception if the stream fails to be created.</exception>
        </member>
        <member name="T:IoC.Configuration.IIoCServiceFactory">
            <summary>
                This class is internal, and outside this project should be used only in test projects
            </summary>
        </member>
        <member name="M:IoC.Configuration.IIoCServiceFactory.CreateAssemblyLocator(System.Func{IoC.Configuration.ConfigurationFile.IConfiguration},System.String)">
            <summary>
                Creates an instance of <see cref="T:IoC.Configuration.IAssemblyLocator" />.
            </summary>
            <param name="getConfugurationFunc">
                A <see cref="T:System.Func`1" /> objects that returns an instance of
                <see cref="T:IoC.Configuration.ConfigurationFile.IConfiguration" />
            </param>
            <param name="entryAssemblyFolder"></param>
        </member>
        <member name="M:IoC.Configuration.IIoCServiceFactory.CreateTypesListFactoryTypeGenerator(OROptimizer.Serializer.ITypeBasedSimpleSerializerAggregator)">
            <summary>
                Creates an instance of <see cref="T:IoC.Configuration.DynamicCode.ITypesListFactoryTypeGenerator" />
            </summary>
        </member>
        <member name="M:IoC.Configuration.IIoCServiceFactory.GetProhibitedServiceTypesInServicesElementChecker">
            <summary>
                Returns instance of <see cref="T:IoC.Configuration.ConfigurationFile.IProhibitedServiceTypesInServicesElementChecker" />.
            </summary>
        </member>
        <member name="P:IoC.Configuration.INamedValue.ValueInstantiationType">
            <summary>
                Normally for injectedObject element this value is <see cref="F:IoC.Configuration.ValueInstantiationType.ResolveFromDiContext" />, for
                other elements (i.e., int16, int32, etc), the overridden value will be
                <see cref="F:IoC.Configuration.ValueInstantiationType.DeserializeFromStringValue" />
            </summary>
        </member>
        <member name="P:IoC.Configuration.INamedValue.ValueType">
            <summary>
                Can be null only if the parameter is declared with either 'object' or injectedObject elements, and the object type
                referenced
                is in a disabled assembly.
            </summary>
        </member>
        <member name="P:IoC.Configuration.IPlugin.PluginData">
            <summary>
                Sets/gets the <see cref="T:IoC.Configuration.IPluginData" /> object corresponding to plugin, retrieved from configuration.
                The implementation should ensure that the plugin data can be set only once, when the configuration is loaded.
                The implementation can subclass from <see cref="T:IoC.Configuration.PluginAbstr" /> to re-use this implementation.
            </summary>
        </member>
        <member name="P:IoC.Configuration.ISetting.DeserializedValue">
            <summary>
                The value deserialized from ValueAsString to type in property <see cref="P:IoC.Configuration.INamedValue.ValueType" />
            </summary>
        </member>
        <member name="P:IoC.Configuration.ISettings.AllSettings">
            <summary>
                A collection of all settings loading from configuration file.
            </summary>
        </member>
        <member name="M:IoC.Configuration.ISettings.GetSetting(System.String)">
            <summary>
                Returns an object of type <see cref="T:IoC.Configuration.ISetting" /> with sata loaded from a setting in configuration file.
            </summary>
            <param name="name">Setting name in configuration file.</param>
            <returns></returns>
        </member>
        <member name="M:IoC.Configuration.ISettings.GetSettingValue``1(System.String,``0,``0@)">
            <summary>
                Gets the value of a setting if the setting is present in configuration file and has the specified type.
                Otherwise, returns the specified default value.
            </summary>
            <typeparam name="T">Setting type in configuration file.</typeparam>
            <param name="name">Setting name in configuration file.</param>
            <param name="defaultValue">
                A value to return, if the setting is not in configuration file, or if it is not of
                type <typeparamref name="T" />.
            </param>
            <param name="value"></param>
            <returns>Returns setting value.</returns>
        </member>
        <member name="M:IoC.Configuration.ISettings.GetSettingValueOrThrow``1(System.String)">
            <summary>
                Gets the value of a setting if the setting is present in configuration file and has the specified type.
                Otherwise, throws an exception.
            </summary>
            <typeparam name="T">Setting type in configuration file.</typeparam>
            <param name="name">Setting name in configuration file</param>
            <returns>Returns setting value.</returns>
            <exception cref="T:System.Exception">Throws this exception.</exception>
        </member>
        <member name="M:IoC.Configuration.MessagesHelper.GetMultipleImplementationsWithRegisterIfNotRegisteredOptionMessage(System.String)">
            <summary>
                Returns a string: The value of <paramref name="registerIfNotRegisteredSubjectName" /> can be true only if there is
                a single implementation for the service.
            </summary>
            <param name="registerIfNotRegisteredSubjectName"></param>
        </member>
        <member name="T:IoC.Configuration.OnApplicationStart.IOnApplicationsStarted">
            <summary>
                Implement this class to configure application, such as executing custom code on application start.
            </summary>
        </member>
        <member name="T:IoC.Configuration.Properties.Resources">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:IoC.Configuration.Properties.Resources.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:IoC.Configuration.Properties.Resources.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:IoC.Configuration.Properties.Resources.IoC_Configuration_Schema_2F7CE7FF_CB22_40B0_9691_EAC689C03A36">
             <summary>
               Looks up a localized string similar to &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
            &lt;xs:schema attributeFormDefault=&quot;unqualified&quot; elementFormDefault=&quot;qualified&quot; xmlns:xs=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;
                &lt;xs:simpleType name=&quot;scopeValues&quot;&gt;
                    &lt;xs:restriction base=&quot;xs:string&quot;&gt;
                        &lt;!--The same object will be used for all service resolutions --&gt;
                        &lt;xs:enumeration value=&quot;singleton&quot;/&gt;
            
                        &lt;!--New object will be created per request--&gt;
                        &lt;xs:enumeration value=&quot;transient&quot;/&gt;
            
                        &lt;!--The same ob [rest of string was truncated]&quot;;.
             </summary>
        </member>
        <member name="P:IoC.Configuration.Properties.Resources.IoC_Configuration_Schema_2F7CE7FF_CB22_40B0_9691_EAC689C03A361">
             <summary>
               Looks up a localized string similar to &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
            &lt;xs:schema attributeFormDefault=&quot;unqualified&quot; elementFormDefault=&quot;qualified&quot; xmlns:xs=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;
                &lt;xs:simpleType name=&quot;scopeValues&quot;&gt;
                    &lt;xs:restriction base=&quot;xs:string&quot;&gt;
                        &lt;!--The same object will be used for all service resolutions --&gt;
                        &lt;xs:enumeration value=&quot;singleton&quot;/&gt;
            
                        &lt;!--New object will be created per request--&gt;
                        &lt;xs:enumeration value=&quot;transient&quot;/&gt;
            
                        &lt;!--The same ob [rest of string was truncated]&quot;;.
             </summary>
        </member>
        <member name="P:IoC.Configuration.Properties.Resources.IoC_Configuration_Schema_2F7CE7FF_CB22_40B0_9691_EAC689C03A362">
             <summary>
               Looks up a localized string similar to &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
            &lt;xs:schema attributeFormDefault=&quot;unqualified&quot; elementFormDefault=&quot;qualified&quot; xmlns:xs=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;
                &lt;xs:simpleType name=&quot;scopeValues&quot;&gt;
                    &lt;xs:restriction base=&quot;xs:string&quot;&gt;
                        &lt;!--The same object will be used for all service resolutions --&gt;
                        &lt;xs:enumeration value=&quot;singleton&quot;/&gt;
            
                        &lt;!--New object will be created per request--&gt;
                        &lt;xs:enumeration value=&quot;transient&quot;/&gt;
            
                        &lt;!--The same ob [rest of string was truncated]&quot;;.
             </summary>
        </member>
        <member name="P:IoC.Configuration.Properties.Resources.IoC_Configuration_Schema_2F7CE7FF_CB22_40B0_9691_EAC689C03A363">
             <summary>
               Looks up a localized string similar to &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
            &lt;xs:schema attributeFormDefault=&quot;unqualified&quot; elementFormDefault=&quot;qualified&quot; xmlns:xs=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;
                &lt;xs:simpleType name=&quot;scopeValues&quot;&gt;
                    &lt;xs:restriction base=&quot;xs:string&quot;&gt;
                        &lt;!--The same object will be used for all service resolutions --&gt;
                        &lt;xs:enumeration value=&quot;singleton&quot;/&gt;
            
                        &lt;!--New object will be created per request--&gt;
                        &lt;xs:enumeration value=&quot;transient&quot;/&gt;
            
                        &lt;!--The same ob [rest of string was truncated]&quot;;.
             </summary>
        </member>
        <member name="M:IoC.Configuration.TempEntryFromDynamicCode.Debug">
            <summary>
                Add a line <see cref="M:IoC.Configuration.TempEntryFromDynamicCode.Debug" />() in dynamically generated code,
                to break into this method and debug the dynamically generated code
            </summary>
        </member>
    </members>
</doc>
