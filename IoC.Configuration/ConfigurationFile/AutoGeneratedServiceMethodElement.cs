// This software is part of the IoC.Configuration library
// Copyright © 2018 IoC.Configuration Contributors
// http://oroptimizer.com
//
// Permission is hereby granted, free of charge, to any person
// obtaining a copy of this software and associated documentation
// files (the "Software"), to deal in the Software without
// restriction, including without limitation the rights to use,
// copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the
// Software is furnished to do so, subject to the following
// conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
// OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
// WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
// OTHER DEALINGS IN THE SOFTWARE.

using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Xml;
using JetBrains.Annotations;
using OROptimizer;

namespace IoC.Configuration.ConfigurationFile
{
    public class AutoGeneratedServiceMethodElement : AutoGeneratedServiceMemberElement, IAutoGeneratedServiceMethodElement
    {
        #region Member Variables

        [NotNull]
        [ItemNotNull]
        private readonly List<IAutoGeneratedMemberReturnValuesIfSelectorElement> _returnedValueSelectorsForIfCase = new List<IAutoGeneratedMemberReturnValuesIfSelectorElement>();

        #endregion

        #region  Constructors

        public AutoGeneratedServiceMethodElement([NotNull] XmlElement xmlElement,
                                                 [NotNull] IAutoGeneratedServiceElement parentAutoGeneratedServiceElement,
                                                 [NotNull] ITypeHelper typeHelper,
                                                 [NotNull] ITypeMemberLookupHelper typeMemberLookupHelper) :
            base(xmlElement, parentAutoGeneratedServiceElement, typeHelper, typeMemberLookupHelper)
        {
        }

        #endregion

        #region IAutoGeneratedServiceMethodElement Interface Implementation

        public override void AddChild(IConfigurationFileElement child)
        {
            base.AddChild(child);

            if (child is IMethodSignatureElement methodSignature)
            {
                MethodSignatureElement = methodSignature;
                InitMethodInfo();
            }
            else if (child is IAutoGeneratedMemberReturnValuesIfSelectorElement returnedValueSelectorForIfCase)
                _returnedValueSelectorsForIfCase.Add(returnedValueSelectorForIfCase);
            else if (child is IAutoGeneratedMemberReturnValuesSelectorElement returnValuesSelector)
                ReturnedValueSelectorsForDefaultCase = returnValuesSelector;
        }

        public override void BeforeChildInitialize(IConfigurationFileElement child)
        {
            base.BeforeChildInitialize(child);

            if (child is IAutoGeneratedMemberReturnValuesSelectorElement || child is IAutoGeneratedMemberReturnValuesIfSelectorElement)
                InitMethodInfo();
        }

        public MethodInfo ImplementedMehodInfo { get; private set; }

        public override void Initialize()
        {
            base.Initialize();

            if (HasAttribute(ConfigurationFileAttributeNames.ReuseValue))
                ReuseReturnedValue = this.GetAttributeValue<bool>(ConfigurationFileAttributeNames.ReuseValue);
        }

        public IMethodSignatureElement MethodSignatureElement { get; private set; }
        public IAutoGeneratedMemberReturnValuesSelectorElement ReturnedValueSelectorsForDefaultCase { get; private set; }
        public IEnumerable<IAutoGeneratedMemberReturnValuesIfSelectorElement> ReturnedValueSelectorsForIfCase => _returnedValueSelectorsForIfCase;
        public bool ReuseReturnedValue { get; private set; }

        public override void ValidateAfterChildrenAdded()
        {
            base.ValidateAfterChildrenAdded();
            InitMethodInfo();
        }

        #endregion

        #region Member Functions

        private bool AreParametersAMatch([NotNull] [ItemNotNull] MethodInfo methodInfo,
                                         [NotNull] [ItemNotNull] Type[] parameterTypes)
        {
            var parameterInfos = methodInfo.GetParameters();

            if (parameterInfos.Length != parameterTypes.Length)
                return false;

            for (var i = 0; i < parameterInfos.Length; ++i)
            {
                var parameterInfo = parameterInfos[i];

                // For now we do not care about out, ref, in parameters.
                // Therefore, these methods will be ignored.
                if (parameterInfo.IsIn || parameterInfo.IsLcid || parameterInfo.IsOut || parameterInfo.IsRetval ||
                    parameterInfo.ParameterType.IsByRef)
                    return false;

                if (parameterInfo.ParameterType != parameterTypes[i])
                    return false;
            }

            return true;
        }

        /*Throws an exception if single method is not found.*/
        private MethodInfo GetMethodInfoInClassOrParents([NotNull] string methodName,
                                                         [NotNull] [ItemNotNull] Type[] parameterTypes)
        {
            StringBuilder errorMessage;
            var matchedMethodInfos = new List<MethodInfo>();

            MethodInfo findMethodInfoInType(Type type)
            {
                foreach (var methodInfo in type.GetMethods())
                {
                    if (methodInfo.Name.Equals(methodName, StringComparison.Ordinal) &&
                        methodInfo.ReturnType == ValueTypeInfo.Type &&
                        methodInfo.IsPublic &&
                        AreParametersAMatch(methodInfo, parameterTypes))
                        return methodInfo;
                }

                return null;
            }

            void appendMethodParametersDescriptionOnInvalidSignature()
            {
                var parametersStrBldr = new StringBuilder();
                parametersStrBldr.Append("Method parameters used for lookup are: ");

                if (parameterTypes.Length == 0)
                {
                    parametersStrBldr.AppendLine("no parameters.");
                }
                else
                {
                    parametersStrBldr.AppendLine(string.Join(", ",
                        MethodSignatureElement.Parameters.Select(x => x.ValueTypeInfo.TypeCSharpFullName)));
                }

                errorMessage.AppendLine(parametersStrBldr.ToString());
                errorMessage.AppendLine("Note, currently methods that use in, ref, out keywords are not considered.");
            }

            if (DeclaringTypeInfoInAttribute != null)
            {
                var matchedMethodInfo = findMethodInfoInType(DeclaringTypeInfoInAttribute.Type);

                if (matchedMethodInfo != null)
                    return matchedMethodInfo;

                errorMessage = new StringBuilder();
                errorMessage.AppendFormat("Method named '{0}', with return type '{1}' and the specified parameters was not found in interface '{2}', specified in  attribute '{3}'.",
                    methodName, ValueTypeInfo.TypeCSharpFullName, DeclaringTypeInfoInAttribute.TypeCSharpFullName, ConfigurationFileAttributeNames.DeclaringInterface);

                errorMessage.AppendLine();

                appendMethodParametersDescriptionOnInvalidSignature();

                errorMessage.AppendLine("Remove the attribute to look in auto-implemented interface, and all the base interfaces.");
                throw new ConfigurationParseException(this, errorMessage.ToString());
            }

            void processType(Type type, ref bool stopProcessing2)
            {
                var methodInfo = findMethodInfoInType(type);

                if (methodInfo != null)
                {
                    matchedMethodInfos.Add(methodInfo);
                    if (type == ParentAutoGeneratedServiceElement.ImplementedInterfaceTypeInfo.Type)
                        stopProcessing2 = true;
                }
            }

            var stopProcessing = false;

            TypeMemberLookupHelper.ProcessTypeImplementedInterfacesAndBaseTypes(
                ParentAutoGeneratedServiceElement.ImplementedInterfaceTypeInfo.Type,
                processType, ref stopProcessing);

            if (matchedMethodInfos.Count == 1)
                return matchedMethodInfos[0];

            errorMessage = new StringBuilder();

            errorMessage.AppendFormat("Method with name '{0}', with return type '{1}' and the specified parameters ",
                methodName, ValueTypeInfo.TypeCSharpFullName);

            if (matchedMethodInfos.Count == 0)
            {
                errorMessage.AppendFormat("was not found in auto-generated interface '{0}' or any of its parents.",
                    ParentAutoGeneratedServiceElement.ImplementedInterfaceTypeInfo.TypeCSharpFullName);
                errorMessage.AppendLine();

                appendMethodParametersDescriptionOnInvalidSignature();
            }
            else
            {
                errorMessage.AppendFormat("was not found in auto-generated interface '{0}', however a method with this name, signature, and return type occurs multiple times in parents of interface '{0}'.",
                    ParentAutoGeneratedServiceElement.ImplementedInterfaceTypeInfo.TypeCSharpFullName);
                errorMessage.AppendLine();
                errorMessage.AppendLine($"Please use attribute '{ConfigurationFileAttributeNames.DeclaringInterface}', to explicitly specify the type, where the auto-implemented method is declared.");

                //--Example of proxy service--
                errorMessage.AppendFormat($"Note, if necessary, you can use '{0}' to proxy the service '{1}'.",
                    ConfigurationFileElementNames.ProxyService, ParentAutoGeneratedServiceElement.ImplementedInterfaceTypeInfo.TypeCSharpFullName);
                errorMessage.AppendLine();

                errorMessage.AppendLine(MessagesHelper.GenerateProxyServiceExample(matchedMethodInfos[0].DeclaringType,
                    ParentAutoGeneratedServiceElement.ImplementedInterfaceTypeInfo.Type));

                // List of parent types
                appendMethodParametersDescriptionOnInvalidSignature();
                errorMessage.AppendLine(
                    string.Format("The following is the list of interfaces, where the method was found: {0}",
                        string.Join(", ", matchedMethodInfos.Select(x => x.DeclaringType.GetTypeNameInCSharpClass()))));
            }

            throw new ConfigurationParseException(this, errorMessage.ToString());
        }

        private void InitMethodInfo()
        {
            if (ImplementedMehodInfo != null)
                return;

            var implementedMethodParameterTypes = MethodSignatureElement == null ? new Type[0] : MethodSignatureElement.Parameters.Select(x => x.ValueTypeInfo.Type).ToArray();

            var implementedMethodInfo = GetMethodInfoInClassOrParents(Name, implementedMethodParameterTypes);

            var reflectionParameters = implementedMethodInfo.GetParameters();
            for (var parameterIndex = 0; parameterIndex < implementedMethodParameterTypes.Length; ++parameterIndex)
            {
                var methodSignatureParameter = MethodSignatureElement.Parameters[parameterIndex];

                var reflectionParameter = reflectionParameters[parameterIndex];
                if (methodSignatureParameter.Name != null && !methodSignatureParameter.Name.Equals(reflectionParameter.Name, StringComparison.Ordinal))
                    throw new ConfigurationParseException(methodSignatureParameter, $"The parameter at index '{parameterIndex}' is named '{reflectionParameter.Name}'. Either remove the '{ConfigurationFileAttributeNames.Name}' attribute, or use this name.", MethodSignatureElement);
            }


            if (implementedMethodInfo.ReturnType != ValueTypeInfo.Type)
            {
                // This will never happen now, however might happen if returnType attribute is made optional in the future.
                throw new ConfigurationParseException(this, $"The value of return type specified in attribute is different from the type of method '{Name}'. The actual return type of the method is '{implementedMethodInfo.ReturnType.FullName}'.");
            }


            ImplementedMehodInfo = implementedMethodInfo;
        }

        #endregion
    }
}