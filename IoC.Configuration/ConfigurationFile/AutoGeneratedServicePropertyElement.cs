// This software is part of the IoC.Configuration library
// Copyright © 2018 IoC.Configuration Contributors
// http://oroptimizer.com
//
// Permission is hereby granted, free of charge, to any person
// obtaining a copy of this software and associated documentation
// files (the "Software"), to deal in the Software without
// restriction, including without limitation the rights to use,
// copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the
// Software is furnished to do so, subject to the following
// conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
// OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
// WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
// OTHER DEALINGS IN THE SOFTWARE.

using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Xml;
using JetBrains.Annotations;
using OROptimizer;

namespace IoC.Configuration.ConfigurationFile
{
    public class AutoGeneratedServicePropertyElement : AutoGeneratedServiceMemberElement, IAutoGeneratedServicePropertyElement,
                                                       ICanHaveCollectionChildElement
    {
        #region  Constructors

        public AutoGeneratedServicePropertyElement([NotNull] XmlElement xmlElement,
                                                   [NotNull] IAutoGeneratedServiceElement parentAutoGeneratedServiceElement,
                                                   [NotNull] ITypeHelper typeHelper,
                                                   [NotNull] ITypeMemberLookupHelper typeMemberLookupHelper) :
            base(xmlElement, parentAutoGeneratedServiceElement, typeHelper, typeMemberLookupHelper)
        {
        }

        #endregion

        #region IAutoGeneratedServicePropertyElement Interface Implementation

        public override void AddChild(IConfigurationFileElement child)
        {
            base.AddChild(child);

            if (child is IReturnValueElement returnValueElement)
            {
                ReturnValueElement = returnValueElement;

                if (!ImplementedPropertyInfo.GetGetMethod().ReturnType.IsTypeAssignableFrom(ReturnValueElement.ValueTypeInfo.Type))
                    throw new ConfigurationParseException(child, $"Property '{Name}' in interface '{ParentAutoGeneratedServiceElement.ImplementedInterfaceTypeInfo.TypeCSharpFullName}' has a type '{ImplementedPropertyInfo.GetGetMethod().ReturnType.FullName}' which is not assignable from type '{ReturnValueElement.ValueTypeInfo.TypeCSharpFullName}'.", this);
            }
        }

        public PropertyInfo ImplementedPropertyInfo { get; private set; }

        public override void Initialize()
        {
            base.Initialize();

            ImplementedPropertyInfo = GetPropertyInfoInClassOrParents(Name);
        }

        public IReturnValueElement ReturnValueElement { get; private set; }

        #endregion

        #region ICanHaveCollectionChildElement Interface Implementation

        public ITypeInfo ExpectedChildTypeInfo => ValueTypeInfo;

        #endregion

        #region Member Functions

        /*Throws an exception if single method is not found.*/
        private PropertyInfo GetPropertyInfoInClassOrParents([NotNull] string propertyName)
        {
            StringBuilder errorMessage;
            var matchedPropertyInfos = new List<PropertyInfo>();

            PropertyInfo findPropertyInfoInType(Type type)
            {
                foreach (var propertyInfo in type.GetProperties())
                {
                    if (!propertyInfo.Name.Equals(propertyName, StringComparison.Ordinal))
                        continue;

                    var getMethodInfo = propertyInfo.GetMethod;

                    if (getMethodInfo != null && getMethodInfo.IsPublic && getMethodInfo.ReturnType == ValueTypeInfo.Type)
                        return propertyInfo;
                }

                return null;
            }

            if (DeclaringTypeInfoInAttribute != null)
            {
                var matchedPropertyInfo = findPropertyInfoInType(DeclaringTypeInfoInAttribute.Type);

                if (matchedPropertyInfo != null)
                    return matchedPropertyInfo;

                errorMessage = new StringBuilder();
                errorMessage.AppendFormat("Property named '{0}', and with return type '{1}' was not found in interface '{2}', specified in  attribute '{3}'.",
                    propertyName, ValueTypeInfo.TypeCSharpFullName, DeclaringTypeInfoInAttribute.TypeCSharpFullName, ConfigurationFileAttributeNames.DeclaringInterface);

                errorMessage.AppendLine();
                errorMessage.AppendLine("Remove the attribute to look in auto-implemented interface, and all the base interfaces.");
                throw new ConfigurationParseException(this, errorMessage.ToString());
            }

            void processType(Type type, ref bool stopProcessing2)
            {
                var propertyInfo = findPropertyInfoInType(type);

                if (propertyInfo != null)
                {
                    matchedPropertyInfos.Add(propertyInfo);

                    if (type == ParentAutoGeneratedServiceElement.ImplementedInterfaceTypeInfo.Type)
                        stopProcessing2 = true;
                }
            }

            var stopProcessing = false;

            TypeMemberLookupHelper.ProcessTypeImplementedInterfacesAndBaseTypes(
                ParentAutoGeneratedServiceElement.ImplementedInterfaceTypeInfo.Type,
                processType, ref stopProcessing);

            if (matchedPropertyInfos.Count == 1)
                return matchedPropertyInfos[0];

            errorMessage = new StringBuilder();

            errorMessage.AppendFormat("Property with name '{0}', and with return type '{1}' ",
                propertyName, ValueTypeInfo.TypeCSharpFullName);

            if (matchedPropertyInfos.Count == 0)
            {
                errorMessage.AppendFormat("was not found in auto-generated interface '{0}' or any of its parents.",
                    ParentAutoGeneratedServiceElement.ImplementedInterfaceTypeInfo.TypeCSharpFullName);
                errorMessage.AppendLine();
            }
            else
            {
                errorMessage.AppendFormat("was not found in auto-generated interface '{0}', however a property with this name and return type occurs multiple times in parents of interface '{0}'.",
                    ParentAutoGeneratedServiceElement.ImplementedInterfaceTypeInfo.TypeCSharpFullName);
                errorMessage.AppendLine();
                errorMessage.AppendLine($"Please use attribute '{ConfigurationFileAttributeNames.DeclaringInterface}', to explicitly specify the type, where the auto-implemented property is declared.");

                //--Example of proxy service--
                errorMessage.AppendFormat($"Note, if necessary, you can use '{0}' to proxy the service '{1}'.",
                    ConfigurationFileElementNames.ProxyService, ParentAutoGeneratedServiceElement.ImplementedInterfaceTypeInfo.TypeCSharpFullName);
                errorMessage.AppendLine();

                errorMessage.AppendLine(MessagesHelper.GenerateProxyServiceExample(matchedPropertyInfos[0].DeclaringType,
                    ParentAutoGeneratedServiceElement.ImplementedInterfaceTypeInfo.Type));

                // List of parent types
                errorMessage.AppendLine(
                    string.Format("The following is the list of interfaces, where the property was found: {0}",
                        string.Join(", ", matchedPropertyInfos.Select(x => x.DeclaringType.GetTypeNameInCSharpClass()))));
            }

            throw new ConfigurationParseException(this, errorMessage.ToString());
        }

        #endregion
    }
}